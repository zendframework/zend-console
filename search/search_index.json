{
    "docs": [
        {
            "location": "/",
            "text": "zend-console\n\n\n\n\n\n\nZend\\Console\n is a component to design and implement console applications in PHP.\n\n\n\n\nDeprecated\n\n\nBoth the zend-console and the \nzend-mvc-console\n\ncomponents will likely not be maintained long-term, as there are more complete\nimplementations available elsewhere. We strongly urge developers to start\nmigrating their console tooling to use other libraries, such as\n\nsymfony/console\n.\n\n\n\n\n\n\nFile issues at https://github.com/zendframework/zend-console/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-console/",
            "title": "Home"
        },
        {
            "location": "/#zend-console",
            "text": "Zend\\Console  is a component to design and implement console applications in PHP.",
            "title": "zend-console"
        },
        {
            "location": "/#deprecated",
            "text": "Both the zend-console and the  zend-mvc-console \ncomponents will likely not be maintained long-term, as there are more complete\nimplementations available elsewhere. We strongly urge developers to start\nmigrating their console tooling to use other libraries, such as symfony/console .    File issues at https://github.com/zendframework/zend-console/issues  Documentation is at https://docs.zendframework.com/zend-console/",
            "title": "Deprecated"
        },
        {
            "location": "/intro/",
            "text": "Introduction to zend-console\n\n\n\n\nDeprecated\n\n\nBoth the zend-console and the \nzend-mvc-console\n\ncomponents will likely not be maintained long-term, as there are more complete\nimplementations available elsewhere. We strongly urge developers to start\nmigrating their console tooling to use other libraries, such as\n\nsymfony/console\n.\n\n\n\n\nzend-console provides both generic support for routable console applications, as\nwell as the basis for adding console support to zend-mvc-based applications.\n\n\nWhen a zend-mvc application is run from a console window (a shell window or\nWindows command prompt), it will recognize this fact and prepare zend-mvc\ncomponents to handle the request. Console support is enabled by default, but to\nfunction properly it requires at least one \nconsole route\n and one\n\naction controller\n\nto handle the request.\n\n\nAlternately, you can build console-aware applications that are standalone;\n\nzf-console\n provides a standardized\nworkflow for doing so.\n\n\nFeatures in zend-console include:\n\n\n\n\nConsole routing\n allows you to invoke handlers (including\n  controller actions) depending on command line parameters provided by the user.\n\n\nConsole adapters\n provide abstraction for interacting with\n  consoles exposed by different operating systems.\n\n\nConsole prompts\n allow user interaction by asking questions and\n  retrieving input.\n\n\n\n\nWhen used with \nzend-mvc\n, the\nfollowing features are also available:\n\n\n\n\nModule Manager integration\n allows zend-mvc applications and\n  modules to display help and usage information, either on demand, or in\n  situations where no route was matched.\n\n\nConsole-aware action controllers\n will receive a console\n  request containing all named parameters and flags. They are able to send\n  output back to the console window.\n\n\n\n\nQuick Start with zend-mvc\n\n\n\n\nThe following example details integration of zend-console with zend-mvc.\nHowever, all information pertaining to routing can also be used \nwithout\n\nzend-mvc, but requires that you react to the routing results yourself. The\naforementioned zf-console provides some basic wiring around that, and can and\nshould be consulted if you do not choose to use zend-console with zend-mvc.\n\n\n\n\nA console route defines required and optional command line parameters. When a\nroute matches, it returns an array of matched parameters \u2014 which may\ninclude default parameters, or even parameters not exposed via the command line\n(e.g., metadata related to the route).\n\n\nLet's assume that we'd like our application to handle the following command line:\n\n\n$ zf user resetpassword user@mail.com\n\n\n\nWhen a user runs our application (\nzf\n) with these parameters, we'd like to call\nthe action \nresetpassword\n of \nApplication\\Controller\\IndexController\n.\n\n\n\n\nThe zf command\n\n\nWe will use \nzf\n to depict the entry point for your application; it can be\na shell script in the application's \nbin/\n directory, or simply an alias for \nphp\npublic/index.php\n.\n\n\n\n\nFirst we need to create a \nroute definition\n:\n\n\nuser resetpassword <userEmail>\n\n\n\nThis simple route definition expects exactly three arguments: the literal\n\"user\", the literal \"resetpassword\", and the dynamic argument we're calling\n\"userEmail\". Let's assume we also accept one optional parameter to enable\nverbose operation:\n\n\nuser resetpassword [--verbose|-v] <userEmail>\n\n\n\nThe modified console route above expects the same three arguments from our\noriginal example, but will also recognise an optional \n--verbose\n flag, or its\nshorthand version, \n-v\n.\n\n\n\n\nFlag order\n\n\nThe order of flags is ignored by zend-console. Flags can appear before\npositional parameters, after them, or anywhere in between. The order of\nmultiple flags is also irrelevant. This applies both to route definitions and\nthe order that flags are used on the command line.\n\n\n\n\nLet's use the definition above and configure our console route. When using\nzend-mvc, console routes are defined using the following configuration\nstructure:\n\n\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are defined here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n\n    /* ... */\n];\n\n\n\nLet's create our console route and point it to\n\nApplication\\Controller\\IndexController::resetpasswordAction()\n:\n\n\n// We could define routes for Application\\Controller\\IndexController in\n// the Application module config file, usually located at\n// modules/application/config/module.config.php, or in one of the\n// config/autoload/*.php files.\nreturn [\n    'console' => [\n        'router' => [\n            'routes' => [\n                'user-reset-password' => [\n                    'options' => [\n                        'route'    => 'user resetpassword [--verbose|-v] <userEmail>',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'resetpassword',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n;\n\n\n\nHandling console requests\n\n\nWhen a user runs our application from the command line and arguments match our\nconsole route, the specified controller will be instantiated, and the specified\naction method will be called, just as happens with zend-mvc HTTP requests.\n\n\nAs such, let's add the \nresetpassword\n action to our\n\nApplication\\Controller\\IndexController\n:\n\n\n<?php\nnamespace Application\\Controller;\n\nuse RuntimeException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Math\\Rand;\n\nclass IndexController extends AbstractActionController\n{\n    /* ... */\n\n    public function resetpasswordAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console, and the user has not\n        // tricked our application into running this action from a public web\n        // server:\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException('You can only use this action from a console!');\n        }\n\n        // Get user email from the console, and check if the user requested\n        // verbosity:\n        $userEmail   = $request->getParam('userEmail');\n        $verbose     = $request->getParam('verbose') || $request->getParam('v');\n\n        // Reset new password\n        $newPassword = Rand::getString(16);\n\n        // Fetch the user and change his password, then email him ...\n        /* ... */\n\n        if ($verbose) {\n            return \"Done! New password for user $userEmail is '$newPassword'. \"\n                . \"It has also been emailed to him.\\n\";\n        }\n\n        return \"Done! $userEmail has received an email with his new password.\\n\";\n\n    }\n}\n\n\n\nThe above creates \nresetpasswordAction()\n, which:\n\n\n\n\nretrieves the current request;\n\n\nchecks if it's really coming from the console (as a precaution); in this\n  example, we do not want our action to be invocable from a web page;\n\n\npulls console arguments via \n$request->getParam()\n; flags are represented by\n  boolean values, where \ntrue\n means the flag was used, and \nfalse\n means\n  otherwise;\n\n\nperforms work based on the arguments;\n\n\nand finally returns a simple string to display to the user via the console.\n\n\n\n\nAdding console usage info\n\n\nConsole applications commonly display usage information when run without\narguments. The combination of zend-console and zend-mvc enables this out of the\nbox. Modules can provide usage information, and zend-console will query all loaded\nmodules for console usage information they expose.\n\n\nLet's modify our \nApplication\\Module\n to provide usage info:\n\n\n<?php\n\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\AutoloaderProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\n/**\n * Implementing ConsoleUsageProviderInterface allows the Module to provide\n * console usage information.\n */\nclass Module implements\n    AutoloaderProviderInterface,\n    ConfigProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConfig()\n    {\n        /* ... */\n    }\n\n    public function getAutoloaderConfig()\n    {\n        /* ... */\n    }\n\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            // Describe available commands\n            'user resetpassword [--verbose|-v] EMAIL' => 'Reset password for a user',\n\n            // Describe expected parameters\n            [ 'EMAIL',        'Email of the user for a password reset' ],\n            [ '--verbose|-v', '(optional) turn on verbose mode'        ],\n        ];\n    }\n}\n\n\n\nEach module that implements \nConsoleUsageProviderInterface\n will be queried for\nconsole usage info.  On route mismatch, all info from all modules will be\nconcatenated, formatted to console width, and shown to the user.\n\n\n\n\nUsage Order\n\n\nThe order of usage info displayed in the console is in the same order in which\nmodules load. If you want your application to display important usage info\nfirst, change the order your modules are loaded.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction-to-zend-console",
            "text": "",
            "title": "Introduction to zend-console"
        },
        {
            "location": "/intro/#deprecated",
            "text": "Both the zend-console and the  zend-mvc-console \ncomponents will likely not be maintained long-term, as there are more complete\nimplementations available elsewhere. We strongly urge developers to start\nmigrating their console tooling to use other libraries, such as symfony/console .   zend-console provides both generic support for routable console applications, as\nwell as the basis for adding console support to zend-mvc-based applications.  When a zend-mvc application is run from a console window (a shell window or\nWindows command prompt), it will recognize this fact and prepare zend-mvc\ncomponents to handle the request. Console support is enabled by default, but to\nfunction properly it requires at least one  console route  and one action controller \nto handle the request.  Alternately, you can build console-aware applications that are standalone; zf-console  provides a standardized\nworkflow for doing so.  Features in zend-console include:   Console routing  allows you to invoke handlers (including\n  controller actions) depending on command line parameters provided by the user.  Console adapters  provide abstraction for interacting with\n  consoles exposed by different operating systems.  Console prompts  allow user interaction by asking questions and\n  retrieving input.   When used with  zend-mvc , the\nfollowing features are also available:   Module Manager integration  allows zend-mvc applications and\n  modules to display help and usage information, either on demand, or in\n  situations where no route was matched.  Console-aware action controllers  will receive a console\n  request containing all named parameters and flags. They are able to send\n  output back to the console window.",
            "title": "Deprecated"
        },
        {
            "location": "/intro/#quick-start-with-zend-mvc",
            "text": "The following example details integration of zend-console with zend-mvc.\nHowever, all information pertaining to routing can also be used  without \nzend-mvc, but requires that you react to the routing results yourself. The\naforementioned zf-console provides some basic wiring around that, and can and\nshould be consulted if you do not choose to use zend-console with zend-mvc.   A console route defines required and optional command line parameters. When a\nroute matches, it returns an array of matched parameters \u2014 which may\ninclude default parameters, or even parameters not exposed via the command line\n(e.g., metadata related to the route).  Let's assume that we'd like our application to handle the following command line:  $ zf user resetpassword user@mail.com  When a user runs our application ( zf ) with these parameters, we'd like to call\nthe action  resetpassword  of  Application\\Controller\\IndexController .",
            "title": "Quick Start with zend-mvc"
        },
        {
            "location": "/intro/#the-zf-command",
            "text": "We will use  zf  to depict the entry point for your application; it can be\na shell script in the application's  bin/  directory, or simply an alias for  php\npublic/index.php .   First we need to create a  route definition :  user resetpassword <userEmail>  This simple route definition expects exactly three arguments: the literal\n\"user\", the literal \"resetpassword\", and the dynamic argument we're calling\n\"userEmail\". Let's assume we also accept one optional parameter to enable\nverbose operation:  user resetpassword [--verbose|-v] <userEmail>  The modified console route above expects the same three arguments from our\noriginal example, but will also recognise an optional  --verbose  flag, or its\nshorthand version,  -v .",
            "title": "The zf command"
        },
        {
            "location": "/intro/#flag-order",
            "text": "The order of flags is ignored by zend-console. Flags can appear before\npositional parameters, after them, or anywhere in between. The order of\nmultiple flags is also irrelevant. This applies both to route definitions and\nthe order that flags are used on the command line.   Let's use the definition above and configure our console route. When using\nzend-mvc, console routes are defined using the following configuration\nstructure:  return [\n    'router' => [\n        'routes' => [\n            // HTTP routes are defined here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n\n    /* ... */\n];  Let's create our console route and point it to Application\\Controller\\IndexController::resetpasswordAction() :  // We could define routes for Application\\Controller\\IndexController in\n// the Application module config file, usually located at\n// modules/application/config/module.config.php, or in one of the\n// config/autoload/*.php files.\nreturn [\n    'console' => [\n        'router' => [\n            'routes' => [\n                'user-reset-password' => [\n                    'options' => [\n                        'route'    => 'user resetpassword [--verbose|-v] <userEmail>',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'resetpassword',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n;",
            "title": "Flag order"
        },
        {
            "location": "/intro/#handling-console-requests",
            "text": "When a user runs our application from the command line and arguments match our\nconsole route, the specified controller will be instantiated, and the specified\naction method will be called, just as happens with zend-mvc HTTP requests.  As such, let's add the  resetpassword  action to our Application\\Controller\\IndexController :  <?php\nnamespace Application\\Controller;\n\nuse RuntimeException;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Math\\Rand;\n\nclass IndexController extends AbstractActionController\n{\n    /* ... */\n\n    public function resetpasswordAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console, and the user has not\n        // tricked our application into running this action from a public web\n        // server:\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException('You can only use this action from a console!');\n        }\n\n        // Get user email from the console, and check if the user requested\n        // verbosity:\n        $userEmail   = $request->getParam('userEmail');\n        $verbose     = $request->getParam('verbose') || $request->getParam('v');\n\n        // Reset new password\n        $newPassword = Rand::getString(16);\n\n        // Fetch the user and change his password, then email him ...\n        /* ... */\n\n        if ($verbose) {\n            return \"Done! New password for user $userEmail is '$newPassword'. \"\n                . \"It has also been emailed to him.\\n\";\n        }\n\n        return \"Done! $userEmail has received an email with his new password.\\n\";\n\n    }\n}  The above creates  resetpasswordAction() , which:   retrieves the current request;  checks if it's really coming from the console (as a precaution); in this\n  example, we do not want our action to be invocable from a web page;  pulls console arguments via  $request->getParam() ; flags are represented by\n  boolean values, where  true  means the flag was used, and  false  means\n  otherwise;  performs work based on the arguments;  and finally returns a simple string to display to the user via the console.",
            "title": "Handling console requests"
        },
        {
            "location": "/intro/#adding-console-usage-info",
            "text": "Console applications commonly display usage information when run without\narguments. The combination of zend-console and zend-mvc enables this out of the\nbox. Modules can provide usage information, and zend-console will query all loaded\nmodules for console usage information they expose.  Let's modify our  Application\\Module  to provide usage info:  <?php\n\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\AutoloaderProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConfigProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\n/**\n * Implementing ConsoleUsageProviderInterface allows the Module to provide\n * console usage information.\n */\nclass Module implements\n    AutoloaderProviderInterface,\n    ConfigProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConfig()\n    {\n        /* ... */\n    }\n\n    public function getAutoloaderConfig()\n    {\n        /* ... */\n    }\n\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            // Describe available commands\n            'user resetpassword [--verbose|-v] EMAIL' => 'Reset password for a user',\n\n            // Describe expected parameters\n            [ 'EMAIL',        'Email of the user for a password reset' ],\n            [ '--verbose|-v', '(optional) turn on verbose mode'        ],\n        ];\n    }\n}  Each module that implements  ConsoleUsageProviderInterface  will be queried for\nconsole usage info.  On route mismatch, all info from all modules will be\nconcatenated, formatted to console width, and shown to the user.",
            "title": "Adding console usage info"
        },
        {
            "location": "/intro/#usage-order",
            "text": "The order of usage info displayed in the console is in the same order in which\nmodules load. If you want your application to display important usage info\nfirst, change the order your modules are loaded.",
            "title": "Usage Order"
        },
        {
            "location": "/adapter/",
            "text": "Console adapters\n\n\nzend-console's console abstraction layer works around various bugs and limitations\nin operating systems, including:\n\n\n\n\ndisplay of colorized text.\n\n\ndiscovery and calculation of console window size.\n\n\ndiscovery of console charset.\n\n\nbasic line drawing capabilities.\n\n\n\n\nConsole adapters implement \nZend\\Console\\Adapter\\AdapterInterface\n, and you\nshould typehint against that interface for purposes of working with console\ncapabilities. Adapters are included for:\n\n\n\n\nPosix (*nix-based systems)\n\n\nWindows (and Windows ANSI; for use with \ncommand.bat\n)\n\n\nVirtual (which provides Windows PowerShell compatibility)\n\n\n\n\nRetrieving the console adapter\n\n\nWhile you may know your current environment, you will want to write your code in\nsuch a way that the console adapter is specific to whatever environment it is\nrun within. As such, you likely should never instantiate an adapter directly.\nzend-console, and the zend-mvc integration, provide tools for retrieving an\nappropriate adapter for the current environment in a generic way.\n\n\nStandalone\n\n\nzend-console provides a factory for creating and returning the console adapter\nspecific to your environment:\n\n\nuse Zend\\Console\\Console;\nuse Zend\\Console\\Exception\\ExceptionInterface as ConsoleException;\n\ntry {\n    $console = Console::getInstance();\n} catch (ConsoleException $e) {\n    // Could not get console adapter; most likely we are not running inside a\n    // console window.\n}\n\n\n\nThis returns a \nZend\\Console\\Adapter\\AdapterInterface\n implementation suitable\nfor your current environment.\n\n\n\n\nExceptions\n\n\nFor practical and security reasons, \nConsole::getInstance()\n will always throw\nan exception if you attempt to get console instance in a non-console\nenvironment (i.e. when running on a HTTP server). You can override this\nbehavior by manually instantiating one of the \nZend\\Console\\Adapter\\*\n\nclasses; you should do this only as a last resort, however!\n\n\n\n\nzend-mvc\n\n\nIf you are using MVC controllers you can obtain Console adapter instance using\nthe \nServiceManager\n.\n\n\nnamespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\nuse Zend\\Console\\Exception\\RuntimeException;\n\nclass ConsoleController extends AbstractActionController\n{\n    public function testAction()\n    {\n        $console = $this->getServiceLocator()->get('console');\n        if (! $console instanceof Console) {\n            throw new RuntimeException('Cannot obtain console adapter. Are we running in a\nconsole?');\n        }\n    }\n}\n\n\n\nIf you extend \nAbstractConsoleController\n, you can use the \ngetConsole()\n method\ninstead:\n\n\nnamespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractConsoleController;\nuse Zend\\Console\\Exception\\RuntimeException;\n\nclass ConsoleController extends AbstractConsoleController\n{\n    public function testAction()\n    {\n        $console = $this->getConsole();\n    }\n}\n\n\n\n\n\nUse dependency injection\n\n\nWe recommend using dependency injection. Instead of pulling the console\nadapter from the service manager, inject it from within your controller's\nfactory. This is essentially what happens when extending\n\nAbstractConsoleController\n already.\n\n\n\n\nUsing the console adapter\n\n\nZend\\Console\\Adapter\\AdapterInterface\n describes a rich set of capabilities.\nBelow is a sampling.\n\n\nWindow size and title\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$console->getWidth()\n\n\n(int) Get real console window width in characters.\n\n\n\n\n\n\n$console->getHeight()\n\n\n(int) Get real console window height in characters.\n\n\n\n\n\n\n$console->getSize()\n\n\n(array) Returns \n[$width, $height]\n with current console window dimensions.\n\n\n\n\n\n\n$console->getTitle()\n\n\n(string) Get console window title.\n\n\n\n\n\n\n\n\n\n\nMultibyte sequences\n\n\nFor UTF-8 enabled consoles, dimensions represent the number of multibyte\ncharacters (real characters).\n\n\nVirtual buffer sizes\n\n\nOn consoles with virtual buffers (e.g. MS Windows Command Prompt), width and\nheight represent visible (real) size, without scrolling the window. For\nexample, if the window scrolling width is 120 chars, but its real, visible\nwidth is 80 chars, \ngetWidth()\n will return \n80\n.\n\n\n\n\nCharacter set\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$console->isUtf8()\n\n\n(boolean) Is the console UTF-8 compatible (can it display unicode strings)?\n\n\n\n\n\n\n$console->getCharset()\n\n\n(\nZend\\Console\\Charset\\CharsetInterface\n) This method will return an instance of one of the \nZend\\Console\\Charset\\*\n classes representing the readable charset present for line-drawing. It is automatically detected by the adapter.\n\n\n\n\n\n\n\n\nWriting to the console\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$console->write(string $text, $color = null, $bgColor = null)\n\n\nWrite \n$text\n to the console, optionally using foreground \n$color\n and background \n$bgColor\n.  Color values must be one of the \nZend\\Console\\ColorInterface\n constants.\n\n\n\n\n\n\n$console->writeLine(string $text, $color = null, $bgColor = null)\n\n\nWrite a single line of \n$text\n to the console. This method will output an environment-specific newline character at the end of the text, moving the console cursor to next line.\n\n\n\n\n\n\n$console->writeAt(string $text, int $x, int $y, $color = null, $bgColor = null)\n\n\nWrite \n$text\n at the specified \n$x\n and \n$y\n coordinates of console window. The top left corner of the screen has coordinates of \n$x = 1; $y = 1\n. To retrieve the far-right and bottom coordinates, use the \ngetWidth()\n and \ngetHeight()\n methods.\n\n\n\n\n\n\n\n\nReading from the console\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$console->readChar(string $mask = null)\n\n\n(string) Read a single character from the console. Optional \n(string) $mask\n can be provided to force entering only a selected set of characters. For example, to read a single digit, we can use the following syntax: \n$digit = $console->readChar('0123456789');\n.\n\n\n\n\n\n\n$console->readLine(int $maxLength = 2048)\n\n\n(string) Read a single line of input from console. Optional \n(int) $maxLength\n can be used to limit the length of data that will be read. The line will be returned \nwithout trailing newline characters\n.\n\n\n\n\n\n\n\n\nMiscellaneous\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$console->hideCursor()\n\n\nHide blinking cursor from the console.\n\n\n\n\n\n\n$console->showCursor()\n\n\nShow blinking cursor in the console.\n\n\n\n\n\n\n$console->clear()\n\n\nClear the screen.\n\n\n\n\n\n\n$console->clearLine()\n\n\nClear the line that the cursor currently sits at.",
            "title": "Console Adapters"
        },
        {
            "location": "/adapter/#console-adapters",
            "text": "zend-console's console abstraction layer works around various bugs and limitations\nin operating systems, including:   display of colorized text.  discovery and calculation of console window size.  discovery of console charset.  basic line drawing capabilities.   Console adapters implement  Zend\\Console\\Adapter\\AdapterInterface , and you\nshould typehint against that interface for purposes of working with console\ncapabilities. Adapters are included for:   Posix (*nix-based systems)  Windows (and Windows ANSI; for use with  command.bat )  Virtual (which provides Windows PowerShell compatibility)",
            "title": "Console adapters"
        },
        {
            "location": "/adapter/#retrieving-the-console-adapter",
            "text": "While you may know your current environment, you will want to write your code in\nsuch a way that the console adapter is specific to whatever environment it is\nrun within. As such, you likely should never instantiate an adapter directly.\nzend-console, and the zend-mvc integration, provide tools for retrieving an\nappropriate adapter for the current environment in a generic way.",
            "title": "Retrieving the console adapter"
        },
        {
            "location": "/adapter/#standalone",
            "text": "zend-console provides a factory for creating and returning the console adapter\nspecific to your environment:  use Zend\\Console\\Console;\nuse Zend\\Console\\Exception\\ExceptionInterface as ConsoleException;\n\ntry {\n    $console = Console::getInstance();\n} catch (ConsoleException $e) {\n    // Could not get console adapter; most likely we are not running inside a\n    // console window.\n}  This returns a  Zend\\Console\\Adapter\\AdapterInterface  implementation suitable\nfor your current environment.",
            "title": "Standalone"
        },
        {
            "location": "/adapter/#exceptions",
            "text": "For practical and security reasons,  Console::getInstance()  will always throw\nan exception if you attempt to get console instance in a non-console\nenvironment (i.e. when running on a HTTP server). You can override this\nbehavior by manually instantiating one of the  Zend\\Console\\Adapter\\* \nclasses; you should do this only as a last resort, however!",
            "title": "Exceptions"
        },
        {
            "location": "/adapter/#zend-mvc",
            "text": "If you are using MVC controllers you can obtain Console adapter instance using\nthe  ServiceManager .  namespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\nuse Zend\\Console\\Exception\\RuntimeException;\n\nclass ConsoleController extends AbstractActionController\n{\n    public function testAction()\n    {\n        $console = $this->getServiceLocator()->get('console');\n        if (! $console instanceof Console) {\n            throw new RuntimeException('Cannot obtain console adapter. Are we running in a\nconsole?');\n        }\n    }\n}  If you extend  AbstractConsoleController , you can use the  getConsole()  method\ninstead:  namespace Application;\n\nuse Zend\\Mvc\\Controller\\AbstractConsoleController;\nuse Zend\\Console\\Exception\\RuntimeException;\n\nclass ConsoleController extends AbstractConsoleController\n{\n    public function testAction()\n    {\n        $console = $this->getConsole();\n    }\n}",
            "title": "zend-mvc"
        },
        {
            "location": "/adapter/#use-dependency-injection",
            "text": "We recommend using dependency injection. Instead of pulling the console\nadapter from the service manager, inject it from within your controller's\nfactory. This is essentially what happens when extending AbstractConsoleController  already.",
            "title": "Use dependency injection"
        },
        {
            "location": "/adapter/#using-the-console-adapter",
            "text": "Zend\\Console\\Adapter\\AdapterInterface  describes a rich set of capabilities.\nBelow is a sampling.",
            "title": "Using the console adapter"
        },
        {
            "location": "/adapter/#window-size-and-title",
            "text": "Method  Description      $console->getWidth()  (int) Get real console window width in characters.    $console->getHeight()  (int) Get real console window height in characters.    $console->getSize()  (array) Returns  [$width, $height]  with current console window dimensions.    $console->getTitle()  (string) Get console window title.",
            "title": "Window size and title"
        },
        {
            "location": "/adapter/#multibyte-sequences",
            "text": "For UTF-8 enabled consoles, dimensions represent the number of multibyte\ncharacters (real characters).",
            "title": "Multibyte sequences"
        },
        {
            "location": "/adapter/#virtual-buffer-sizes",
            "text": "On consoles with virtual buffers (e.g. MS Windows Command Prompt), width and\nheight represent visible (real) size, without scrolling the window. For\nexample, if the window scrolling width is 120 chars, but its real, visible\nwidth is 80 chars,  getWidth()  will return  80 .",
            "title": "Virtual buffer sizes"
        },
        {
            "location": "/adapter/#character-set",
            "text": "Method  Description      $console->isUtf8()  (boolean) Is the console UTF-8 compatible (can it display unicode strings)?    $console->getCharset()  ( Zend\\Console\\Charset\\CharsetInterface ) This method will return an instance of one of the  Zend\\Console\\Charset\\*  classes representing the readable charset present for line-drawing. It is automatically detected by the adapter.",
            "title": "Character set"
        },
        {
            "location": "/adapter/#writing-to-the-console",
            "text": "Method  Description      $console->write(string $text, $color = null, $bgColor = null)  Write  $text  to the console, optionally using foreground  $color  and background  $bgColor .  Color values must be one of the  Zend\\Console\\ColorInterface  constants.    $console->writeLine(string $text, $color = null, $bgColor = null)  Write a single line of  $text  to the console. This method will output an environment-specific newline character at the end of the text, moving the console cursor to next line.    $console->writeAt(string $text, int $x, int $y, $color = null, $bgColor = null)  Write  $text  at the specified  $x  and  $y  coordinates of console window. The top left corner of the screen has coordinates of  $x = 1; $y = 1 . To retrieve the far-right and bottom coordinates, use the  getWidth()  and  getHeight()  methods.",
            "title": "Writing to the console"
        },
        {
            "location": "/adapter/#reading-from-the-console",
            "text": "Method  Description      $console->readChar(string $mask = null)  (string) Read a single character from the console. Optional  (string) $mask  can be provided to force entering only a selected set of characters. For example, to read a single digit, we can use the following syntax:  $digit = $console->readChar('0123456789'); .    $console->readLine(int $maxLength = 2048)  (string) Read a single line of input from console. Optional  (int) $maxLength  can be used to limit the length of data that will be read. The line will be returned  without trailing newline characters .",
            "title": "Reading from the console"
        },
        {
            "location": "/adapter/#miscellaneous",
            "text": "Method  Description      $console->hideCursor()  Hide blinking cursor from the console.    $console->showCursor()  Show blinking cursor in the console.    $console->clear()  Clear the screen.    $console->clearLine()  Clear the line that the cursor currently sits at.",
            "title": "Miscellaneous"
        },
        {
            "location": "/prompts/",
            "text": "Console prompts\n\n\nIn addition to the console abstraction layer, zend-console provides numerous\nconvenience classes for interacting with the user in a console environment. This\nchapter describes available \nZend\\Console\\Prompt\n classes and their usage.\n\n\nAll prompts can be instantiated directly, and expose a \nshow()\n method.\n\n\nuse Zend\\Console\\Prompt;\n\n$confirm = new Prompt\\Confirm('Are you sure you want to continue?');\n$result = $confirm->show();\nif ($result) {\n    // the user chose to continue\n}\n\n\n\nYou can also use prompts statically, via the static \nprompt()\n method:\n\n\nuse Zend\\Console\\Prompt;\n\n$result = Prompt\\Confirm::prompt('Are you sure you want to continue?');\nif ($result) {\n    // the user chose to continue\n}\n\n\n\nBoth of above examples will display something like this:\n\n\n\n\nConfirm\n\n\nThis prompt is best used for \nyes\n / \nno\n prompts.\n\n\nConfirm(string $text, string $yesChar = 'y', string $noChar = 'n') : bool\n\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$text\n\n\n(string) The text to show with the prompt.\n\n\n\n\n\n\n$yesChar\n\n\n(string) The character that corresponds with the YES choice. (default is \ny\n)\n\n\n\n\n\n\n$noChar\n\n\n(string) The character that corresponds with the NO choice. (default is \nn\n)\n\n\n\n\n\n\n\n\nExample usage:\n\n\nuse Zend\\Console\\Prompt\\Confirm;\n\nif ( Confirm::prompt('Is this the correct answer? [y/n]', 'y', 'n')) {\n    $console->write(\"You chose YES\");\n} else {\n    $console->write(\"You chose NO\");\n}\n\n\n\n\n\nLine\n\n\nThis prompt asks for a line of text input.\n\n\nLine(\n    string $text = 'Please enter value',\n    bool $allowEmpty = false,\n    bool $maxLength = 2048\n) : string\n\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$text\n\n\n(string) The text to show with the prompt.\n\n\n\n\n\n\n$allowEmpty\n\n\n(boolean) Can this prompt be skipped, by pressing \n[ENTER]\n?  (default is false)\n\n\n\n\n\n\n$maxLength\n\n\n(integer) Maximum length of the input. Anything above this limit will be truncated.\n\n\n\n\n\n\n\n\nExample usage:\n\n\nuse Zend\\Console\\Prompt\\Line;\n\n$name = Line::prompt(\n    'What is your name?',\n    false,\n    100\n);\n\n$console->write(\"Good day to you $name!\");\n\n\n\n\n\nChar\n\n\nThis prompt reads a single keystroke, and optionally validates it against a list\nof allowed characters.\n\n\nChar(\n    string $text = 'Please hit a key',\n    string $allowedChars = 'abc',\n    bool $ignoreCase = true,\n    bool $allowEmpty = false,\n    bool $echo = true\n) : string\n\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$text\n\n\n(string) The text to show with the prompt.\n\n\n\n\n\n\n$allowedChars\n\n\n(string) A list of allowed keys that can be pressed.\n\n\n\n\n\n\n$ignoreCase\n\n\n(boolean) Ignore the case of chars pressed (default is true).\n\n\n\n\n\n\n$allowEmpty\n\n\n(boolean) Can this prompt be skipped, by pressing \n[ENTER]\n?  (default is false)\n\n\n\n\n\n\n$echo\n\n\n(boolean) Should the selection be displayed on the screen?\n\n\n\n\n\n\n\n\nExample usage:\n\n\nuse Zend\\Console\\Prompt\\Char;\n\n$answer = Char::prompt(\n    'What is the correct answer? [a,b,c,d,e]',\n    'abcde',\n    true,\n    false,\n    true\n);\n\nif ($answer == 'b') {\n    $console->write('Correct. This is the right answer.');\n} else {\n    $console->write('Wrong! Try again.');\n}\n\n\n\n\n\nSelect\n\n\nThis prompt displays a number of choices, and asks the user to pick one.\n\n\nSelect(\n    string $text = 'Please select one option',\n    array $options = [],\n    bool $allowEmpty = false,\n    bool $echo = false\n) : string\n\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$text\n\n\n(string) The text to show with the prompt.\n\n\n\n\n\n\n$options\n\n\n(array) An associative array with keys strokes (chars) and their displayed values.\n\n\n\n\n\n\n$allowEmpty\n\n\n(boolean) Can this prompt be skipped, by pressing \n[ENTER]\n?  (default is false)\n\n\n\n\n\n\n$echo\n\n\n(boolean) Should the selection be displayed on the screen?\n\n\n\n\n\n\n\n\nExample usage:\n\n\n$options = [\n    'a' => 'Apples',\n    'o' => 'Oranges',\n    'p' => 'Pears',\n    'b' => 'Bananas',\n    'n' => 'none of the above...',\n];\n\n$answer = Select::prompt(\n    'Which fruit do you like the best?',\n    $options,\n    false,\n    false\n);\n\n$console->write(\"You told me that you like \" . $options[$answer]);\n\n\n\n\n\nPassword\n\n\nThis prompt reads in a string, without echoing that string back to the console;\nthe most common use case is password prompts, which gives it its name.\n\n\nPassword(\n    string $promptText = 'Password : ',\n    boolean $echo = true\n) : string\n\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$promptText\n\n\n(string) The text to show with the prompt.\n\n\n\n\n\n\n$echo\n\n\n(bool) Display \n*\n in place of each character typed. Can be skipped.  (default is \ntrue\n)\n\n\n\n\n\n\n\n\nExample usage:\n\n\nuse Zend\\Console\\Prompt\\Password;\n\n$password = Password::prompt('Enter the secret', true);\n\n$console->write(\"Sh!, the password is $password\");",
            "title": "Console Prompts"
        },
        {
            "location": "/prompts/#console-prompts",
            "text": "In addition to the console abstraction layer, zend-console provides numerous\nconvenience classes for interacting with the user in a console environment. This\nchapter describes available  Zend\\Console\\Prompt  classes and their usage.  All prompts can be instantiated directly, and expose a  show()  method.  use Zend\\Console\\Prompt;\n\n$confirm = new Prompt\\Confirm('Are you sure you want to continue?');\n$result = $confirm->show();\nif ($result) {\n    // the user chose to continue\n}  You can also use prompts statically, via the static  prompt()  method:  use Zend\\Console\\Prompt;\n\n$result = Prompt\\Confirm::prompt('Are you sure you want to continue?');\nif ($result) {\n    // the user chose to continue\n}  Both of above examples will display something like this:",
            "title": "Console prompts"
        },
        {
            "location": "/prompts/#confirm",
            "text": "This prompt is best used for  yes  /  no  prompts.  Confirm(string $text, string $yesChar = 'y', string $noChar = 'n') : bool     Argument  Description      $text  (string) The text to show with the prompt.    $yesChar  (string) The character that corresponds with the YES choice. (default is  y )    $noChar  (string) The character that corresponds with the NO choice. (default is  n )     Example usage:  use Zend\\Console\\Prompt\\Confirm;\n\nif ( Confirm::prompt('Is this the correct answer? [y/n]', 'y', 'n')) {\n    $console->write(\"You chose YES\");\n} else {\n    $console->write(\"You chose NO\");\n}",
            "title": "Confirm"
        },
        {
            "location": "/prompts/#line",
            "text": "This prompt asks for a line of text input.  Line(\n    string $text = 'Please enter value',\n    bool $allowEmpty = false,\n    bool $maxLength = 2048\n) : string     Argument  Description      $text  (string) The text to show with the prompt.    $allowEmpty  (boolean) Can this prompt be skipped, by pressing  [ENTER] ?  (default is false)    $maxLength  (integer) Maximum length of the input. Anything above this limit will be truncated.     Example usage:  use Zend\\Console\\Prompt\\Line;\n\n$name = Line::prompt(\n    'What is your name?',\n    false,\n    100\n);\n\n$console->write(\"Good day to you $name!\");",
            "title": "Line"
        },
        {
            "location": "/prompts/#char",
            "text": "This prompt reads a single keystroke, and optionally validates it against a list\nof allowed characters.  Char(\n    string $text = 'Please hit a key',\n    string $allowedChars = 'abc',\n    bool $ignoreCase = true,\n    bool $allowEmpty = false,\n    bool $echo = true\n) : string     Argument  Description      $text  (string) The text to show with the prompt.    $allowedChars  (string) A list of allowed keys that can be pressed.    $ignoreCase  (boolean) Ignore the case of chars pressed (default is true).    $allowEmpty  (boolean) Can this prompt be skipped, by pressing  [ENTER] ?  (default is false)    $echo  (boolean) Should the selection be displayed on the screen?     Example usage:  use Zend\\Console\\Prompt\\Char;\n\n$answer = Char::prompt(\n    'What is the correct answer? [a,b,c,d,e]',\n    'abcde',\n    true,\n    false,\n    true\n);\n\nif ($answer == 'b') {\n    $console->write('Correct. This is the right answer.');\n} else {\n    $console->write('Wrong! Try again.');\n}",
            "title": "Char"
        },
        {
            "location": "/prompts/#select",
            "text": "This prompt displays a number of choices, and asks the user to pick one.  Select(\n    string $text = 'Please select one option',\n    array $options = [],\n    bool $allowEmpty = false,\n    bool $echo = false\n) : string     Argument  Description      $text  (string) The text to show with the prompt.    $options  (array) An associative array with keys strokes (chars) and their displayed values.    $allowEmpty  (boolean) Can this prompt be skipped, by pressing  [ENTER] ?  (default is false)    $echo  (boolean) Should the selection be displayed on the screen?     Example usage:  $options = [\n    'a' => 'Apples',\n    'o' => 'Oranges',\n    'p' => 'Pears',\n    'b' => 'Bananas',\n    'n' => 'none of the above...',\n];\n\n$answer = Select::prompt(\n    'Which fruit do you like the best?',\n    $options,\n    false,\n    false\n);\n\n$console->write(\"You told me that you like \" . $options[$answer]);",
            "title": "Select"
        },
        {
            "location": "/prompts/#password",
            "text": "This prompt reads in a string, without echoing that string back to the console;\nthe most common use case is password prompts, which gives it its name.  Password(\n    string $promptText = 'Password : ',\n    boolean $echo = true\n) : string     Argument  Description      $promptText  (string) The text to show with the prompt.    $echo  (bool) Display  *  in place of each character typed. Can be skipped.  (default is  true )     Example usage:  use Zend\\Console\\Prompt\\Password;\n\n$password = Password::prompt('Enter the secret', true);\n\n$console->write(\"Sh!, the password is $password\");",
            "title": "Password"
        },
        {
            "location": "/routes/",
            "text": "Console routes and routing\n\n\nA powerful feature the zend-console component exposes is \nrouting\n. Routing\nreads the command line arguments and matches them to criteria; if the criteria\nmatches, it then returns a list of matched parameters and flags.\n\n\n\n\nHandling routing results\n\n\nzend-console exposes routing via the \nZend\\Console\\RouteMatcher\\DefaultRouteMatcher\n\nclass, allowing you to create standalone routable console applications.\n\n\nzend-mvc provides structure around routing results to controllers, which\nwe \ndetail in the MVC Routing chapter\n.\n\n\nAnother option is \nzf-console\n, which\nprovides a convenience wrapper around supplying routes and dispatching route\nhandlers.\n\n\n\n\nRouteMatcherInterface\n\n\nzend-console defines an interface for routing,\n\nZend\\Console\\RouteMatcher\\RouteMatcherInterface\n, which defines a single\nmethod, \nmatch()\n:\n\n\nnamespace Zend\\Console\\RouteMatcher;\n\ninterface RouteMatcherInterface\n{\n    /**\n     * Match parameters against route passed to constructor\n     *\n     * @param array $params\n     * @return array|null\n     */\n    public function match($params);\n}\n\n\n\nApplications are expected to retrieve arguments from the console and pass them to\nthe routing implementation as an array; the routing implementation will then\nreturn either a \nnull\n value (meaning failure to match), or an associative array\n(the values matched).\n\n\nThe default route matcher\n\n\nzend-console's default routing implementation is \nZend\\Console\\RouteMatcher\\DefaultRouteMatcher\n.\nIts constructor expects:\n\n\n    /**\n     * @param string $route\n     * @param array $constraints\n     * @param array $defaults\n     * @param array $aliases\n     * @param array $filters\n     * @param ValidatorInterface[] $validators\n     * @throws Exception\\InvalidArgumentException\n     */\n    public function __construct(\n        $route,\n        array $constraints = [],\n        array $defaults = [],\n        array $aliases = [],\n        array $filters = null,\n        array $validators = null\n    )\n\n\n\nThe arguments are as follows:\n\n\n\n\n$route\n is a string pattern describing the argument list it will match.\n\n\n$constraints\n is an associative array, with the keys being named arguments,\n  and the values being regular expressions to match against.\n\n\n$defaults\n are an an associative array of named arguments, with the default\n  value to use if no value was provided; these should only be provided for\n  optional arguments (more on that below).\n\n\n$aliases\n is an associative array where the key values are the alias names,\n  and the string values are the named argument the alias points to; if an alias\n  is used in the invocation, it will be returned using the named argument\n  instead. As an example, if you provide the alias \n'FOO' => 'foo'\n, and have\n  defined \n--foo=\n in the \n$route\n, you can invoke it with \n--FOO=something\n,\n  and the router will map it to the \nfoo\n value.\n\n\n$filters\n is an associative array of named arguments pointing to a\n  \nZend\\Filter\\FilterInterface\n instance (or \nFilterChain\n instance);\n  filters are used to normalize the value associated with the argument.\n\n\n$validators\n is an associative array of named arguments pointing to a\n  \nZend\\Validator\\ValidatorInterface\n instance (or \nValidatorChain\n instance);\n  validators are used to validate values, and provide more options than simply\n  regular expressions (as used with the \n$constraints\n).\n\n\n\n\n\n\nSingle routes only\n\n\nDefaultRouteMatcher\n instances define \na single console route to match\n. Most\ntimes, you will want to define multiple routes. The zend-mvc integration and\nzf-console both provide methods for aggregating routes.\n\n\n\n\nRouting strings\n\n\nRouting strings consist of one or more of the following:\n\n\n\n\nLiteral parameters\n (e.g. \ncreate object (external|internal)\n)\n\n\nLiteral flags\n (e.g. \n--verbose --direct [-d] [-a]\n)\n\n\nPositional value parameters\n (e.g. \ncreate <modelName> [<destination>]\n)\n\n\nValue flags\n (e.g. \n--name=NAME [--method=METHOD]\n)\n\n\nNamed literal alternative groups\n (e.g., \n(all|some|none):filter\n)\n\n\nCatch-all parameters\n (e.g. \n[...params]\n)\n\n\n\n\nLiteral parameters\n\n\nLiteral parameters\n are expected to appear on the command line exactly the way\nthey are provided in the route. For example:\n\n\nshow users\n\n\n\nThis route will \nonly\n match for the following command line\n\n\n$ zf show users\n\n\n\nIt expects the \nmandatory literal parameters\n \nshow users\n. It will not match\nif there are any more parameters, or if either one of the two words is missing.\nThe order of words is also enforced.\n\n\nYou can also provide \noptional literal parameters\n. As an example:\n\n\nshow [all] users\n\n\n\nThe above route will match each of the following:\n\n\n$ zf show users\n$ zf show all users\n\n\n\nYou can also provide \nparameter alternatives\n:\n\n\nshow [all|deleted|locked|admin] users\n\n\n\nThe above route will match both with and without the second parameter; if\nprovided, however, it must be one of the words listed. This enables matching any\nof the following:\n\n\n$ zf show users\n$ zf show locked users\n$ zf show admin users\n# etc.\n\n\n\n\n\nWhitespace is ignored\n\n\nWhitespaces in route definitions are ignored. If you separate your parameters\nwith more spaces, or separate alternatives and pipe characters with spaces,\nthe parser will ignore the whitespace.\nThe above route definition is equivalent to:\n\n\nshow [  all | deleted | locked | admin  ]   users\n\n\n\nAs such, you can use whitespace for readability.\n\n\n\n\nLiteral flags\n\n\nConsole tools commonly use flags. zend-console allows you to define any number\nof optional and/or mandatory flags.\n\n\nFlag order is ignored; they can be defined in any order, and the user can\nprovide them in any order.\n\n\nThe following is a route with \noptional long flags\n:\n\n\ncheck users [--verbose] [--fast] [--thorough]\n\n\n\nThe above route will match commands like:\n\n\n$ zf check users\n$ zf check users --fast\n$ zf check users --verbose --thorough\n$ zf check users --thorough --fast\n# etc\n\n\n\nYou can also define one or more \nmandatory long flags\n, and group them as an\nalternative:\n\n\ncheck users (--suspicious|--expired) [--verbose] [--fast] [--thorough]\n\n\n\nThe above will only match if we provide either the \n--suspicious\n or \n--expired\n\nflag:\n\n\n$ zf check users --expired\n$ zf check users --expired --fast\n$ zf check users --verbose --thorough --suspicious\n\n\n\nShort flags\n are also available, and may be grouped with long flags for\nconvenience:\n\n\ncheck users [--verbose|-v] [--fast|-f] [--thorough|-t]\n\n\n\nNow we can use short versions of our flags:\n\n\n$ zf check users -f\n$ zf check users -v --thorough\n$ zf check users -t -f -v\n# etc.\n\n\n\nPositional value parameters\n\n\nValue parameters capture any text-based input, and come in two forms: positional\nand flags (which we've already discussed).\n\n\nPositional value parameters\n are expected to appear in an \nexact\n position on\nthe command line, and are denoted using angle brackets (\n<>\n).\n\n\nConsider the following:\n\n\ndelete user <userEmail>\n\n\n\nThis route will match the following commands:\n\n\n$ zf delete user john@acme.org\n$ zf delete user betty@acme.org\n\n\n\nWhen matched, the router will return the value under the key we provided in the\nroute definition. If using the \nDefaultRouteMatcher\n standalone, this would be:\n\n\n$matches = $route->match($argv);\n$userEmail = $matches['userEmail'];\n\n\n\nUnder zend-mvc, you will pull the parameter from the request:\n\n\n$userEmail = $this->getRequest()->getParam('userEmail');\n\n\n\nYou can also define \noptional positional value parameters\n by surrounding the\nparameter with square brackets:\n\n\ndelete user [<userEmail>]\n\n\n\nIn this case, the \nuserEmail\n parameter will not be required for the route to\nmatch. If it is not provided, the \nuserEmail\n parameter will not be present in\nthe matched parameters.\n\n\nYou can define any number of positional value parameters:\n\n\ncreate user <firstName> <lastName> <email> <position>\n\n\n\nThis allows us to capture commands such as the following:\n\n\n$ zf create user Johnny Bravo john@acme.org Entertainer\n\n\n\n\n\nEscaping\n\n\nCommand line arguments on all systems must be properly escaped; otherwise they\nwill not be passed to our application correctly. For example, to create a user\nwith two names and a complex position description, we would issue the command\nlike this:\n\n\n$ zf create user \"Johnan Tom\" Bravo john@acme.org \"Head of the Entertainment Department\"\n\n\n\n\n\nValue flag parameters\n\n\nPositional value parameters are only matched if they appear in the exact order described in the\nroute. If we do not want to enforce the order of parameters, we can define \nvalue flags\n.\n\n\nValue flags\n can be defined and matched in \nany\n order, and can receive any\ntext-based value.\n\n\nfind user [--id=] [--firstName=] [--lastName=] [--email=] [--position=]\n\n\n\nThe above route will match for any of the following routes:\n\n\n$ zf find user\n$ zf find user --id 29110\n$ zf find user --id=29110\n$ zf find user --firstName=Johny --lastName=Bravo\n$ zf find user --lastName Bravo --firstName Johny\n$ zf find user --position=Executive --firstName=Bob\n$ zf find user --position \"Head of the Entertainment Department\"\n# etc.\n\n\n\nAs noted, the order of flags is irrelevant for the parser.\n\n\n\n\nProviding values\n\n\nThe parser understands values that are provided after either an equals symbol\n(\n=\n) or a single space, but only if the value itself does not contain\nwhitespace.  Values containing any whitespace  must be properly quoted and\nappear following a space \nonly\n; you cannot use the \n=\n sign to assign such\nvalues.\n\n\n\n\nIn the previous example, all value flags are optional. You may also define\n\nmandatory value flags\n by omitting the square brackets:\n\n\nrename user --id= [--firstName=] [--lastName=]\n\n\n\nIn the above example, the \n--id\n parameter \nis required\n for the route to\nmatch. The following commands will work with this route:\n\n\n$ zf rename user --id 123\n$ zf rename user --id 123 --firstName Jonathan\n$ zf rename user --id=123 --lastName=Bravo\n# etc.\n\n\n\nGrouping literal alternatives\n\n\nIn the flags section, we demonstrated grouping alternative flags:\n\n\ncheck users (--suspicious|--expired) [--verbose] [--fast] [--thorough]\n\n\n\nThis can also be done with literals:\n\n\nshow (all|deleted|locked|admin) <group>\n\n\n\nHowever, this makes checking for which alternative was used quite difficult:\n\n\nswitch (true) {\n    case (isset($params['all'])):\n        // all members\n        break;\n    case (isset($params['deleted'])):\n        // deleted members\n        break;\n    /* etc. */\n}\n\n\n\nTo simplify this, you can \nassign a name to the grouped alternatives\n. Do this\nwith the verbiage \n:groupname\n following the group:\n\n\nshow (all|deleted|locked|admin):filter <group>\n\n\n\nThe above names the group \"filter\". When a group is provided a name, you can\nthen retrieve the group name parameter, which will be set to the alternative\nused:\n\n\nswitch ($params['filter']) {\n    case 'all':\n        // all members\n        break;\n    case 'deleted':\n        // deleted members\n        break;\n    /* etc. */\n}\n\n\n\nCatch-all Parameters\n\n\n\n\nSince 2.7.0\n\n\n\n\nWhen a route may receive a variable number of parameters (for example, to\nimplement a feature like echo, or to process an arbitrary list of files),\nyou can use a catch-all parameter to collect all parameters that are not\nmatched by another part of the route. These collected values can be accessed\nas a single parameter (whose name is defined in the route) containing an array.\n\n\nWhen used, the catch-all parameter must come after all positional value\nparameters. You can only use one catch-all parameter per route.\n\n\nExample:\n\n\nsay [loudly|softly]:volume [...words]\n\n\n\nIf the user entered the command line \nsay loudly I am here\n, the 'volume'\nparameter would contain \n'loudly'\n and the 'words' parameter would contain\n\n['I', 'am', 'here']\n.\n\n\nConsole routes cheat-sheet\n\n\n\n\n\n\n\n\nParam type\n\n\nExample route definition\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nLiteral params\n\n\n\n\n\n\n\n\n\n\nLiteral\n\n\nfoo bar\n\n\n\"foo\" followed by \"bar\"\n\n\n\n\n\n\nLiteral alternative\n\n\nfoo (bar|baz)\n\n\n\"foo\" followed by \"bar\" or \"baz\"\n\n\n\n\n\n\nLiteral, optional\n\n\nfoo [bar]\n\n\n\"foo\", optional \"bar\"\n\n\n\n\n\n\nLiteral, optional alternative\n\n\nfoo [bar|baz]\n\n\n\"foo\", optional \"bar\" or \"baz\"\n\n\n\n\n\n\nFlags\n\n\n\n\n\n\n\n\n\n\nFlag long\n\n\nfoo --bar\n\n\n\"foo\" as first parameter, \"--bar\" flag before or after\n\n\n\n\n\n\nFlag long, optional\n\n\nfoo [--bar]\n\n\n\"foo\" as first parameter, optional \"--bar\" flag before or after\n\n\n\n\n\n\nFlag long, optional, alternative\n\n\nfoo [--bar|--baz]\n\n\n\"foo\" as first parameter, optional \"--bar\" or \"--baz\", before or after\n\n\n\n\n\n\nFlag short\n\n\nfoo -b\n\n\n\"foo\" as first parameter, \"-b\" flag before or after\n\n\n\n\n\n\nFlag short, optional\n\n\nfoo [-b]\n\n\n\"foo\" as first parameter, optional \"-b\" flag before or after\n\n\n\n\n\n\nFlag short, optional, alternative\n\n\nfoo [-b|-z]\n\n\n\"foo\" as first parameter, optional \"-b\" or \"-z\", before or after\n\n\n\n\n\n\nFlag long/short alternative\n\n\nfoo [--bar|-b]\n\n\n\"foo\" as first parameter, optional \"--bar\" or \"-b\" before or after\n\n\n\n\n\n\nValue parameters\n\n\n\n\n\n\n\n\n\n\nValue positional param\n\n\nfoo <bar>\n\n\n\"foo\" followed by any text (stored as \"bar\" param)\n\n\n\n\n\n\nValue positional param, optional\n\n\nfoo [<bar>]\n\n\n\"foo\", optionally followed by any text (stored as \"bar\" param)\n\n\n\n\n\n\nValue Flag\n\n\nfoo --bar=\n\n\n\"foo\" as first parameter, \"--bar\" with a value, before or after\n\n\n\n\n\n\nValue Flag, optional\n\n\nfoo [--bar=]\n\n\n\"foo\" as first parameter, optionally \"--bar\" with a value, before or after\n\n\n\n\n\n\nParameter groups\n\n\n\n\n\n\n\n\n\n\nLiteral params group\n\n\nfoo (bar|baz):myParam\n\n\n\"foo\" followed by \"bar\" or \"baz\" (stored as \"myParam\" param)\n\n\n\n\n\n\nLiteral optional params group\n\n\nfoo [bar|baz]:myParam\n\n\n\"foo\" followed by optional \"bar\" or \"baz\" (stored as \"myParam\" param)\n\n\n\n\n\n\nLong flags group\n\n\nfoo (--bar|--baz):myParam\n\n\n\"foo\", \"bar\" or \"baz\" flag before or after (stored as \"myParam\" param)\n\n\n\n\n\n\nLong optional flags group\n\n\nfoo [--bar|--baz]:myParam\n\n\n\"foo\", optional \"bar\" or \"baz\" flag before or after (as \"myParam\" param)\n\n\n\n\n\n\nShort flags group\n\n\nfoo (-b|-z):myParam\n\n\n\"foo\", \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param)\n\n\n\n\n\n\nShort optional flags group\n\n\nfoo [-b|-z]:myParam\n\n\n\"foo\", optional \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param)\n\n\n\n\n\n\nCatch-all parameters\n\n\n\n\n\n\n\n\n\n\nSimple catch-all\n\n\nfoo [...bar]\n\n\n\"foo\" followed by any number of params, stored as array in \"bar\" param\n\n\n\n\n\n\nLiteral alternative w/ catch-all\n\n\nfoo (bar|baz) [...xyzzy]\n\n\n\"foo\" followed by \"bar\" or \"baz\", with extra input stored as \"xyzzy\" param\n\n\n\n\n\n\nValue param w/ catch-all\n\n\nfoo <bar> [...baz]\n\n\n\"foo\", with first parameter stored as \"bar\" and remainder stored as \"baz\"",
            "title": "Routes"
        },
        {
            "location": "/routes/#console-routes-and-routing",
            "text": "A powerful feature the zend-console component exposes is  routing . Routing\nreads the command line arguments and matches them to criteria; if the criteria\nmatches, it then returns a list of matched parameters and flags.",
            "title": "Console routes and routing"
        },
        {
            "location": "/routes/#handling-routing-results",
            "text": "zend-console exposes routing via the  Zend\\Console\\RouteMatcher\\DefaultRouteMatcher \nclass, allowing you to create standalone routable console applications.  zend-mvc provides structure around routing results to controllers, which\nwe  detail in the MVC Routing chapter .  Another option is  zf-console , which\nprovides a convenience wrapper around supplying routes and dispatching route\nhandlers.",
            "title": "Handling routing results"
        },
        {
            "location": "/routes/#routematcherinterface",
            "text": "zend-console defines an interface for routing, Zend\\Console\\RouteMatcher\\RouteMatcherInterface , which defines a single\nmethod,  match() :  namespace Zend\\Console\\RouteMatcher;\n\ninterface RouteMatcherInterface\n{\n    /**\n     * Match parameters against route passed to constructor\n     *\n     * @param array $params\n     * @return array|null\n     */\n    public function match($params);\n}  Applications are expected to retrieve arguments from the console and pass them to\nthe routing implementation as an array; the routing implementation will then\nreturn either a  null  value (meaning failure to match), or an associative array\n(the values matched).",
            "title": "RouteMatcherInterface"
        },
        {
            "location": "/routes/#the-default-route-matcher",
            "text": "zend-console's default routing implementation is  Zend\\Console\\RouteMatcher\\DefaultRouteMatcher .\nIts constructor expects:      /**\n     * @param string $route\n     * @param array $constraints\n     * @param array $defaults\n     * @param array $aliases\n     * @param array $filters\n     * @param ValidatorInterface[] $validators\n     * @throws Exception\\InvalidArgumentException\n     */\n    public function __construct(\n        $route,\n        array $constraints = [],\n        array $defaults = [],\n        array $aliases = [],\n        array $filters = null,\n        array $validators = null\n    )  The arguments are as follows:   $route  is a string pattern describing the argument list it will match.  $constraints  is an associative array, with the keys being named arguments,\n  and the values being regular expressions to match against.  $defaults  are an an associative array of named arguments, with the default\n  value to use if no value was provided; these should only be provided for\n  optional arguments (more on that below).  $aliases  is an associative array where the key values are the alias names,\n  and the string values are the named argument the alias points to; if an alias\n  is used in the invocation, it will be returned using the named argument\n  instead. As an example, if you provide the alias  'FOO' => 'foo' , and have\n  defined  --foo=  in the  $route , you can invoke it with  --FOO=something ,\n  and the router will map it to the  foo  value.  $filters  is an associative array of named arguments pointing to a\n   Zend\\Filter\\FilterInterface  instance (or  FilterChain  instance);\n  filters are used to normalize the value associated with the argument.  $validators  is an associative array of named arguments pointing to a\n   Zend\\Validator\\ValidatorInterface  instance (or  ValidatorChain  instance);\n  validators are used to validate values, and provide more options than simply\n  regular expressions (as used with the  $constraints ).",
            "title": "The default route matcher"
        },
        {
            "location": "/routes/#single-routes-only",
            "text": "DefaultRouteMatcher  instances define  a single console route to match . Most\ntimes, you will want to define multiple routes. The zend-mvc integration and\nzf-console both provide methods for aggregating routes.",
            "title": "Single routes only"
        },
        {
            "location": "/routes/#routing-strings",
            "text": "Routing strings consist of one or more of the following:   Literal parameters  (e.g.  create object (external|internal) )  Literal flags  (e.g.  --verbose --direct [-d] [-a] )  Positional value parameters  (e.g.  create <modelName> [<destination>] )  Value flags  (e.g.  --name=NAME [--method=METHOD] )  Named literal alternative groups  (e.g.,  (all|some|none):filter )  Catch-all parameters  (e.g.  [...params] )",
            "title": "Routing strings"
        },
        {
            "location": "/routes/#literal-parameters",
            "text": "Literal parameters  are expected to appear on the command line exactly the way\nthey are provided in the route. For example:  show users  This route will  only  match for the following command line  $ zf show users  It expects the  mandatory literal parameters   show users . It will not match\nif there are any more parameters, or if either one of the two words is missing.\nThe order of words is also enforced.  You can also provide  optional literal parameters . As an example:  show [all] users  The above route will match each of the following:  $ zf show users\n$ zf show all users  You can also provide  parameter alternatives :  show [all|deleted|locked|admin] users  The above route will match both with and without the second parameter; if\nprovided, however, it must be one of the words listed. This enables matching any\nof the following:  $ zf show users\n$ zf show locked users\n$ zf show admin users\n# etc.",
            "title": "Literal parameters"
        },
        {
            "location": "/routes/#whitespace-is-ignored",
            "text": "Whitespaces in route definitions are ignored. If you separate your parameters\nwith more spaces, or separate alternatives and pipe characters with spaces,\nthe parser will ignore the whitespace.\nThe above route definition is equivalent to:  show [  all | deleted | locked | admin  ]   users  As such, you can use whitespace for readability.",
            "title": "Whitespace is ignored"
        },
        {
            "location": "/routes/#literal-flags",
            "text": "Console tools commonly use flags. zend-console allows you to define any number\nof optional and/or mandatory flags.  Flag order is ignored; they can be defined in any order, and the user can\nprovide them in any order.  The following is a route with  optional long flags :  check users [--verbose] [--fast] [--thorough]  The above route will match commands like:  $ zf check users\n$ zf check users --fast\n$ zf check users --verbose --thorough\n$ zf check users --thorough --fast\n# etc  You can also define one or more  mandatory long flags , and group them as an\nalternative:  check users (--suspicious|--expired) [--verbose] [--fast] [--thorough]  The above will only match if we provide either the  --suspicious  or  --expired \nflag:  $ zf check users --expired\n$ zf check users --expired --fast\n$ zf check users --verbose --thorough --suspicious  Short flags  are also available, and may be grouped with long flags for\nconvenience:  check users [--verbose|-v] [--fast|-f] [--thorough|-t]  Now we can use short versions of our flags:  $ zf check users -f\n$ zf check users -v --thorough\n$ zf check users -t -f -v\n# etc.",
            "title": "Literal flags"
        },
        {
            "location": "/routes/#positional-value-parameters",
            "text": "Value parameters capture any text-based input, and come in two forms: positional\nand flags (which we've already discussed).  Positional value parameters  are expected to appear in an  exact  position on\nthe command line, and are denoted using angle brackets ( <> ).  Consider the following:  delete user <userEmail>  This route will match the following commands:  $ zf delete user john@acme.org\n$ zf delete user betty@acme.org  When matched, the router will return the value under the key we provided in the\nroute definition. If using the  DefaultRouteMatcher  standalone, this would be:  $matches = $route->match($argv);\n$userEmail = $matches['userEmail'];  Under zend-mvc, you will pull the parameter from the request:  $userEmail = $this->getRequest()->getParam('userEmail');  You can also define  optional positional value parameters  by surrounding the\nparameter with square brackets:  delete user [<userEmail>]  In this case, the  userEmail  parameter will not be required for the route to\nmatch. If it is not provided, the  userEmail  parameter will not be present in\nthe matched parameters.  You can define any number of positional value parameters:  create user <firstName> <lastName> <email> <position>  This allows us to capture commands such as the following:  $ zf create user Johnny Bravo john@acme.org Entertainer",
            "title": "Positional value parameters"
        },
        {
            "location": "/routes/#escaping",
            "text": "Command line arguments on all systems must be properly escaped; otherwise they\nwill not be passed to our application correctly. For example, to create a user\nwith two names and a complex position description, we would issue the command\nlike this:  $ zf create user \"Johnan Tom\" Bravo john@acme.org \"Head of the Entertainment Department\"",
            "title": "Escaping"
        },
        {
            "location": "/routes/#value-flag-parameters",
            "text": "Positional value parameters are only matched if they appear in the exact order described in the\nroute. If we do not want to enforce the order of parameters, we can define  value flags .  Value flags  can be defined and matched in  any  order, and can receive any\ntext-based value.  find user [--id=] [--firstName=] [--lastName=] [--email=] [--position=]  The above route will match for any of the following routes:  $ zf find user\n$ zf find user --id 29110\n$ zf find user --id=29110\n$ zf find user --firstName=Johny --lastName=Bravo\n$ zf find user --lastName Bravo --firstName Johny\n$ zf find user --position=Executive --firstName=Bob\n$ zf find user --position \"Head of the Entertainment Department\"\n# etc.  As noted, the order of flags is irrelevant for the parser.",
            "title": "Value flag parameters"
        },
        {
            "location": "/routes/#providing-values",
            "text": "The parser understands values that are provided after either an equals symbol\n( = ) or a single space, but only if the value itself does not contain\nwhitespace.  Values containing any whitespace  must be properly quoted and\nappear following a space  only ; you cannot use the  =  sign to assign such\nvalues.   In the previous example, all value flags are optional. You may also define mandatory value flags  by omitting the square brackets:  rename user --id= [--firstName=] [--lastName=]  In the above example, the  --id  parameter  is required  for the route to\nmatch. The following commands will work with this route:  $ zf rename user --id 123\n$ zf rename user --id 123 --firstName Jonathan\n$ zf rename user --id=123 --lastName=Bravo\n# etc.",
            "title": "Providing values"
        },
        {
            "location": "/routes/#grouping-literal-alternatives",
            "text": "In the flags section, we demonstrated grouping alternative flags:  check users (--suspicious|--expired) [--verbose] [--fast] [--thorough]  This can also be done with literals:  show (all|deleted|locked|admin) <group>  However, this makes checking for which alternative was used quite difficult:  switch (true) {\n    case (isset($params['all'])):\n        // all members\n        break;\n    case (isset($params['deleted'])):\n        // deleted members\n        break;\n    /* etc. */\n}  To simplify this, you can  assign a name to the grouped alternatives . Do this\nwith the verbiage  :groupname  following the group:  show (all|deleted|locked|admin):filter <group>  The above names the group \"filter\". When a group is provided a name, you can\nthen retrieve the group name parameter, which will be set to the alternative\nused:  switch ($params['filter']) {\n    case 'all':\n        // all members\n        break;\n    case 'deleted':\n        // deleted members\n        break;\n    /* etc. */\n}",
            "title": "Grouping literal alternatives"
        },
        {
            "location": "/routes/#catch-all-parameters",
            "text": "Since 2.7.0   When a route may receive a variable number of parameters (for example, to\nimplement a feature like echo, or to process an arbitrary list of files),\nyou can use a catch-all parameter to collect all parameters that are not\nmatched by another part of the route. These collected values can be accessed\nas a single parameter (whose name is defined in the route) containing an array.  When used, the catch-all parameter must come after all positional value\nparameters. You can only use one catch-all parameter per route.  Example:  say [loudly|softly]:volume [...words]  If the user entered the command line  say loudly I am here , the 'volume'\nparameter would contain  'loudly'  and the 'words' parameter would contain ['I', 'am', 'here'] .",
            "title": "Catch-all Parameters"
        },
        {
            "location": "/routes/#console-routes-cheat-sheet",
            "text": "Param type  Example route definition  Explanation      Literal params      Literal  foo bar  \"foo\" followed by \"bar\"    Literal alternative  foo (bar|baz)  \"foo\" followed by \"bar\" or \"baz\"    Literal, optional  foo [bar]  \"foo\", optional \"bar\"    Literal, optional alternative  foo [bar|baz]  \"foo\", optional \"bar\" or \"baz\"    Flags      Flag long  foo --bar  \"foo\" as first parameter, \"--bar\" flag before or after    Flag long, optional  foo [--bar]  \"foo\" as first parameter, optional \"--bar\" flag before or after    Flag long, optional, alternative  foo [--bar|--baz]  \"foo\" as first parameter, optional \"--bar\" or \"--baz\", before or after    Flag short  foo -b  \"foo\" as first parameter, \"-b\" flag before or after    Flag short, optional  foo [-b]  \"foo\" as first parameter, optional \"-b\" flag before or after    Flag short, optional, alternative  foo [-b|-z]  \"foo\" as first parameter, optional \"-b\" or \"-z\", before or after    Flag long/short alternative  foo [--bar|-b]  \"foo\" as first parameter, optional \"--bar\" or \"-b\" before or after    Value parameters      Value positional param  foo <bar>  \"foo\" followed by any text (stored as \"bar\" param)    Value positional param, optional  foo [<bar>]  \"foo\", optionally followed by any text (stored as \"bar\" param)    Value Flag  foo --bar=  \"foo\" as first parameter, \"--bar\" with a value, before or after    Value Flag, optional  foo [--bar=]  \"foo\" as first parameter, optionally \"--bar\" with a value, before or after    Parameter groups      Literal params group  foo (bar|baz):myParam  \"foo\" followed by \"bar\" or \"baz\" (stored as \"myParam\" param)    Literal optional params group  foo [bar|baz]:myParam  \"foo\" followed by optional \"bar\" or \"baz\" (stored as \"myParam\" param)    Long flags group  foo (--bar|--baz):myParam  \"foo\", \"bar\" or \"baz\" flag before or after (stored as \"myParam\" param)    Long optional flags group  foo [--bar|--baz]:myParam  \"foo\", optional \"bar\" or \"baz\" flag before or after (as \"myParam\" param)    Short flags group  foo (-b|-z):myParam  \"foo\", \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param)    Short optional flags group  foo [-b|-z]:myParam  \"foo\", optional \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param)    Catch-all parameters      Simple catch-all  foo [...bar]  \"foo\" followed by any number of params, stored as array in \"bar\" param    Literal alternative w/ catch-all  foo (bar|baz) [...xyzzy]  \"foo\" followed by \"bar\" or \"baz\", with extra input stored as \"xyzzy\" param    Value param w/ catch-all  foo <bar> [...baz]  \"foo\", with first parameter stored as \"bar\" and remainder stored as \"baz\"",
            "title": "Console routes cheat-sheet"
        },
        {
            "location": "/mvc/routing/",
            "text": "MVC Routing\n\n\nzend-mvc provides integration with zend-console, routing command line arguments\nto the appropriate action controller and action method that will handle the\nrequest. Actions can perform any number of tasks prior to returning a result to\ndisplay in the console window.\n\n\nWhen using zend-mvc, console routes are provided via configuration.\n\n\n// The following can sit inside of module/Application/config/module.config.php,\n// any other module's configuration, or within files under config/autoload/:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n];\n\n\n\nConsole routes exposed via zend-mvc will only be processed when the application\nis run inside a console (terminal) window; they are not used for web (HTTP)\nrequests. It is possible to define only HTTP routes (web application only), only\nconsole routes (console-only application), or a mixture of the two.\n\n\nAs an example of a single route:\n\n\n// inside config.console.router.routes:\n'my-first-route' => [\n    'type'    => 'simple',  // This is the default, and may be omitted; more on\n                            // types below\n    'options' => [\n        'route'    => 'foo bar',\n        'defaults' => [\n            'controller' => Application\\Controller\\Index::class,\n            'action'     => 'password',\n        ],\n    ],\n],\n\n\n\nWe have created a \nsimple\n console route with the name \nmy-first-route\n. It\nexpects two parameters: \nfoo\n and \nbar\n. If user puts these in a console,\n\nApplication\\Controller\\IndexController::passwordAction()\n action will be\ninvoked.\n\n\nRoute types\n\n\nIn the last example of the previous section, we noted that configuration for a\ngiven route can accept a \ntype\n argument. This refers to the route type (which\nmaps to a class) to use when creating the route instance. zend-mvc defines\nseveral types.\n\n\nSimple route\n\n\nZend\\Mvc\\Router\\Console\\Simple\n is a factory for zend-console's\n\nDefaultRouteMatcher\n, and decorates it to work with the zend-mvc routing\nsystem. See the section on \nthe default route matcher\n\nfor details on route strings and available configuration to provide.\n\n\nCatchall route\n\n\nThis special route will catch all console requests, regardless of the parameters provided.\n\n\n'default-route' => [\n    'type'     => 'catchall',\n    'options' => [\n        'route'    => '',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index',\n            'action'     => 'consoledefault',\n        ],\n    ],\n],\n\n\n\nThis route type is rarely used; one possible use case is to register it as the\nlast console route, in order to display usage information. Before you do so,\nread about the \npreferred way of displaying console usage\ninformation\n; following recommendations will guarantee proper\ninteroperation with other modules in your application.",
            "title": "MVC Routing"
        },
        {
            "location": "/mvc/routing/#mvc-routing",
            "text": "zend-mvc provides integration with zend-console, routing command line arguments\nto the appropriate action controller and action method that will handle the\nrequest. Actions can perform any number of tasks prior to returning a result to\ndisplay in the console window.  When using zend-mvc, console routes are provided via configuration.  // The following can sit inside of module/Application/config/module.config.php,\n// any other module's configuration, or within files under config/autoload/:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n];  Console routes exposed via zend-mvc will only be processed when the application\nis run inside a console (terminal) window; they are not used for web (HTTP)\nrequests. It is possible to define only HTTP routes (web application only), only\nconsole routes (console-only application), or a mixture of the two.  As an example of a single route:  // inside config.console.router.routes:\n'my-first-route' => [\n    'type'    => 'simple',  // This is the default, and may be omitted; more on\n                            // types below\n    'options' => [\n        'route'    => 'foo bar',\n        'defaults' => [\n            'controller' => Application\\Controller\\Index::class,\n            'action'     => 'password',\n        ],\n    ],\n],  We have created a  simple  console route with the name  my-first-route . It\nexpects two parameters:  foo  and  bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction()  action will be\ninvoked.",
            "title": "MVC Routing"
        },
        {
            "location": "/mvc/routing/#route-types",
            "text": "In the last example of the previous section, we noted that configuration for a\ngiven route can accept a  type  argument. This refers to the route type (which\nmaps to a class) to use when creating the route instance. zend-mvc defines\nseveral types.",
            "title": "Route types"
        },
        {
            "location": "/mvc/routing/#simple-route",
            "text": "Zend\\Mvc\\Router\\Console\\Simple  is a factory for zend-console's DefaultRouteMatcher , and decorates it to work with the zend-mvc routing\nsystem. See the section on  the default route matcher \nfor details on route strings and available configuration to provide.",
            "title": "Simple route"
        },
        {
            "location": "/mvc/routing/#catchall-route",
            "text": "This special route will catch all console requests, regardless of the parameters provided.  'default-route' => [\n    'type'     => 'catchall',\n    'options' => [\n        'route'    => '',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index',\n            'action'     => 'consoledefault',\n        ],\n    ],\n],  This route type is rarely used; one possible use case is to register it as the\nlast console route, in order to display usage information. Before you do so,\nread about the  preferred way of displaying console usage\ninformation ; following recommendations will guarantee proper\ninteroperation with other modules in your application.",
            "title": "Catchall route"
        },
        {
            "location": "/mvc/modules/",
            "text": "Console-aware modules\n\n\nzend-mvc integrates with zend-console; the integration also works with modules\nloaded with the\n\nModule Manager\n.\n\n\nzend-mvc ships with a console-specific \nRouteNotFoundStrategy\n which is responsible for displaying console usage information when:\n\n\n\n\nthe user has not provided any arguments; or\n\n\narguments could not be matched by any routes.\n\n\n\n\nThe strategy currently supports two types of information: \napplication\nbanners\n and \nusage information\n.\n\n\nApplication banner\n\n\nWhen using zend-console within a zend-mvc application, you can invoke it via\nthe application bootstrap:\n\n\n$ php public/index.php\n\n\n\nBy default, it will simply output the current ZF 2 version, like this:\n\n\n\n\nOur \nApplication\n module (and any other module) can provide an \napplication\nbanner\n. In order to do so, our \nModule\n class has to implement\n\nZend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface\n. As an example:\n\n\n// module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return 'MyModule 0.0.1';\n    }\n}\n\n\n\nAs you can see, the application banner should be a single line string that\nreturns the module's name and (if available) its current version.\n\n\nIf several modules define their own banner, they are displayed one after the\nother in the order in which the modules are loaded. This allows you to see at a\nglance which modules expose console commands.\n\n\nIf we execute our console application now, we'll see the newly created banner:\n\n\n\n\nLet's create and load a second module that provides a banner:\n\n\n<?php\n// config/application.config.php\nreturn array(\n    'modules' => array(\n        'Application',\n        'User',     // <- load user module in module/User\n    ),\n\n\n\nThe \nUser\n module will provide info about itself:\n\n\n// module/User/Module.php\n<?php\nnamespace User;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return \"User Module 0.0.1\";\n    }\n}\n\n\n\nBecause the \nUser\n module is loaded after the \nApplication\n module, the result\nwill look like this:\n\n\n\n\n\n\nApplication banner display\n\n\nApplication banners provided by modules are displayed as-is \u2014 no\ntrimming or other adjustments will be performed on the text. As you can see,\nbanners are also automatically colorized as blue.\n\n\n\n\nUsage information\n\n\nIn order to display usage information, our Module class must implement\n\nZend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface\n. Let's modify our\nexample and add the new method defined in that interface:\n\n\n// module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements\n    ConsoleBannerProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConsoleBanner(Console $console)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method is defined in ConsoleUsageProviderInterface\n     */\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            'show stats'             => 'Show application statistics',\n            'run cron'               => 'Run automated jobs',\n            '(enable|disable) debug' => 'Enable or disable debug mode for the application.',\n        ];\n    }\n}\n\n\n\nThis will display the following information:\n\n\n\n\nSimilar to \napplication banners\n, multiple modules can\nprovide usage information, which will be joined together and displayed to the\nuser. The order in which usage information is displayed is the order in which\nmodules are loaded.\n\n\nAs you can see, the zend-mvc integration also prepends each module's usage with\nthe module's name. This helps to visually separate commands by module \u2014\nwhich is particularly useful when you have multiple modules providing commands.\nBy default, the component colorizes the module names in red.\n\n\n\n\nUsage information is arbitrary\n\n\nUsage info provided in modules is not connected with \nconsole\nrouting\n. You can describe console usage in any form you prefer,\nand it does not affect how MVC handles console commands. In order to handle\nreal console requests, you still need to define console routes.\n\n\n\n\nFree-form text\n\n\nIn order to output free-form text as usage information, \ngetConsoleUsage()\n can\nreturn a string or an array of strings. As an example, the following is a\nsingle, free-form usage text:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return 'User module expects exactly one argument - user name. '\n        . 'It will display information for the provided user.';\n}\n\n\n\n\n\n\n\nUsage text is provided as-is\n\n\nThe text provided is displayed as-is; no trimming or other adjustments will\nbe performed. If you'd like to fit your usage information inside the console\nwindow, you could check its width with \n$console-getWidth()\n.\n\n\n\n\nList of commands\n\n\nIf \ngetConsoleUsage()\n returns an associative array, it will be automatically\naligned in 2 columns.  The first column will be prepended with script name (the\nentry point for the application). This is useful to display the various\ncommands exposed.\n\n\npublic function getConsoleUsage(Console $console)\n{\n     return [\n        'delete user <userEmail>'        => 'Delete user with email <userEmail>',\n        'disable user <userEmail>'       => 'Disable user with email <userEmail>',\n        'list [all|disabled] users'      => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n     ];\n}\n\n\n\n\n\n\n\nCommand list alignment\n\n\nCommands and their descriptions will be aligned in two columns that fit\ninside the terminal window. If the window is resized, text may wrap, but all\ncontent will be aligned. If you don't like the behavior, you can always\nreturn \nfree-form text\n instead, as free-form text is never\ntransformed or aligned.\n\n\n\n\nList of params and flags\n\n\nReturning an array of arrays from \ngetConsoleUsage()\n will produce a listing of\nparameters. This is useful for explaining flags, switches, possible values and\nother information. The output will be aligned in multiple columns for\nreadability.\n\n\nAs an example:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'email of the user' ],\n        [ '--verbose',   'Turn on verbose mode' ],\n        [ '--quick',     'Perform a \"quick\" operation' ],\n        [ '-v',          'Same as --verbose' ],\n        [ '-w',          'Wide output'],\n    );\n}\n\n\n\n\n\nThis method can be used to display more than 2 columns of information:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'user email',        'Full email address of the user to find.' ],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing' ],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish' ],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing' ],\n        [ '-w',          'wide output',       'When listing users, use the whole available screen width' ],\n    ];\n}\n\n\n\n\n\n\n\nAlignment\n\n\nAll information will be aligned in one or more columns that fit inside the\nterminal window. If the window is resized, some text may wrap, but all\ncontent will remain aligned. In case the number of columns changes (e.g. the\narray contains different number of elements), a new table will be created,\nwith its own alignment and column widths.\n\n\nIf you don't like this behavior, you can always return \nfree-form text\n.\n\n\n\n\nMixing styles\n\n\nYou can use mix together all of the above styles to provide comprehensive usage information.\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        'Finding and listing users',\n        'list [all|disabled] users [-w]' => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n\n        ['[all|disabled]', 'Display all users or only disabled accounts'],\n        ['--email=EMAIL',  'Email of the user to find'],\n        ['--name=NAME',    'Full name of the user to find.'],\n        ['-w',             'Wide output - When listing users use the whole available screen width'],\n\n        'Manipulation of user database:',\n        'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>',\n        'disable user <userEmail> [--verbose|-v]'          => 'Disable user with email <userEmail>',\n\n        [ '<userEmail>', 'user email',        'Full email address of the user to change.'],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing'],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish'],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing'],\n\n    );\n}\n\n\n\n\n\nBest practices\n\n\nHere are the best practices when providing usage for your commands:\n\n\n\n\nYour module's \ngetConsoleBanner()\n method should return a one-line string\n   containing the module's name and its version (if available); do not provide any\n   other information.\n\n\nYour \ngetConsoleUsage()\n method should \nnot\n return the module's name, as it\n   is prepended automatically for you by the zend-mvc integration.",
            "title": "Console-Aware Modules"
        },
        {
            "location": "/mvc/modules/#console-aware-modules",
            "text": "zend-mvc integrates with zend-console; the integration also works with modules\nloaded with the Module Manager .  zend-mvc ships with a console-specific  RouteNotFoundStrategy  which is responsible for displaying console usage information when:   the user has not provided any arguments; or  arguments could not be matched by any routes.   The strategy currently supports two types of information:  application\nbanners  and  usage information .",
            "title": "Console-aware modules"
        },
        {
            "location": "/mvc/modules/#application-banner",
            "text": "When using zend-console within a zend-mvc application, you can invoke it via\nthe application bootstrap:  $ php public/index.php  By default, it will simply output the current ZF 2 version, like this:   Our  Application  module (and any other module) can provide an  application\nbanner . In order to do so, our  Module  class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example:  // module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return 'MyModule 0.0.1';\n    }\n}  As you can see, the application banner should be a single line string that\nreturns the module's name and (if available) its current version.  If several modules define their own banner, they are displayed one after the\nother in the order in which the modules are loaded. This allows you to see at a\nglance which modules expose console commands.  If we execute our console application now, we'll see the newly created banner:   Let's create and load a second module that provides a banner:  <?php\n// config/application.config.php\nreturn array(\n    'modules' => array(\n        'Application',\n        'User',     // <- load user module in module/User\n    ),  The  User  module will provide info about itself:  // module/User/Module.php\n<?php\nnamespace User;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return \"User Module 0.0.1\";\n    }\n}  Because the  User  module is loaded after the  Application  module, the result\nwill look like this:",
            "title": "Application banner"
        },
        {
            "location": "/mvc/modules/#application-banner-display",
            "text": "Application banners provided by modules are displayed as-is \u2014 no\ntrimming or other adjustments will be performed on the text. As you can see,\nbanners are also automatically colorized as blue.",
            "title": "Application banner display"
        },
        {
            "location": "/mvc/modules/#usage-information",
            "text": "In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our\nexample and add the new method defined in that interface:  // module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements\n    ConsoleBannerProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConsoleBanner(Console $console)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method is defined in ConsoleUsageProviderInterface\n     */\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            'show stats'             => 'Show application statistics',\n            'run cron'               => 'Run automated jobs',\n            '(enable|disable) debug' => 'Enable or disable debug mode for the application.',\n        ];\n    }\n}  This will display the following information:   Similar to  application banners , multiple modules can\nprovide usage information, which will be joined together and displayed to the\nuser. The order in which usage information is displayed is the order in which\nmodules are loaded.  As you can see, the zend-mvc integration also prepends each module's usage with\nthe module's name. This helps to visually separate commands by module \u2014\nwhich is particularly useful when you have multiple modules providing commands.\nBy default, the component colorizes the module names in red.",
            "title": "Usage information"
        },
        {
            "location": "/mvc/modules/#usage-information-is-arbitrary",
            "text": "Usage info provided in modules is not connected with  console\nrouting . You can describe console usage in any form you prefer,\nand it does not affect how MVC handles console commands. In order to handle\nreal console requests, you still need to define console routes.",
            "title": "Usage information is arbitrary"
        },
        {
            "location": "/mvc/modules/#free-form-text",
            "text": "In order to output free-form text as usage information,  getConsoleUsage()  can\nreturn a string or an array of strings. As an example, the following is a\nsingle, free-form usage text:  public function getConsoleUsage(Console $console)\n{\n    return 'User module expects exactly one argument - user name. '\n        . 'It will display information for the provided user.';\n}",
            "title": "Free-form text"
        },
        {
            "location": "/mvc/modules/#usage-text-is-provided-as-is",
            "text": "The text provided is displayed as-is; no trimming or other adjustments will\nbe performed. If you'd like to fit your usage information inside the console\nwindow, you could check its width with  $console-getWidth() .",
            "title": "Usage text is provided as-is"
        },
        {
            "location": "/mvc/modules/#list-of-commands",
            "text": "If  getConsoleUsage()  returns an associative array, it will be automatically\naligned in 2 columns.  The first column will be prepended with script name (the\nentry point for the application). This is useful to display the various\ncommands exposed.  public function getConsoleUsage(Console $console)\n{\n     return [\n        'delete user <userEmail>'        => 'Delete user with email <userEmail>',\n        'disable user <userEmail>'       => 'Disable user with email <userEmail>',\n        'list [all|disabled] users'      => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n     ];\n}",
            "title": "List of commands"
        },
        {
            "location": "/mvc/modules/#command-list-alignment",
            "text": "Commands and their descriptions will be aligned in two columns that fit\ninside the terminal window. If the window is resized, text may wrap, but all\ncontent will be aligned. If you don't like the behavior, you can always\nreturn  free-form text  instead, as free-form text is never\ntransformed or aligned.",
            "title": "Command list alignment"
        },
        {
            "location": "/mvc/modules/#list-of-params-and-flags",
            "text": "Returning an array of arrays from  getConsoleUsage()  will produce a listing of\nparameters. This is useful for explaining flags, switches, possible values and\nother information. The output will be aligned in multiple columns for\nreadability.  As an example:  public function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'email of the user' ],\n        [ '--verbose',   'Turn on verbose mode' ],\n        [ '--quick',     'Perform a \"quick\" operation' ],\n        [ '-v',          'Same as --verbose' ],\n        [ '-w',          'Wide output'],\n    );\n}   This method can be used to display more than 2 columns of information:  public function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'user email',        'Full email address of the user to find.' ],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing' ],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish' ],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing' ],\n        [ '-w',          'wide output',       'When listing users, use the whole available screen width' ],\n    ];\n}",
            "title": "List of params and flags"
        },
        {
            "location": "/mvc/modules/#alignment",
            "text": "All information will be aligned in one or more columns that fit inside the\nterminal window. If the window is resized, some text may wrap, but all\ncontent will remain aligned. In case the number of columns changes (e.g. the\narray contains different number of elements), a new table will be created,\nwith its own alignment and column widths.  If you don't like this behavior, you can always return  free-form text .",
            "title": "Alignment"
        },
        {
            "location": "/mvc/modules/#mixing-styles",
            "text": "You can use mix together all of the above styles to provide comprehensive usage information.  public function getConsoleUsage(Console $console)\n{\n    return [\n        'Finding and listing users',\n        'list [all|disabled] users [-w]' => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n\n        ['[all|disabled]', 'Display all users or only disabled accounts'],\n        ['--email=EMAIL',  'Email of the user to find'],\n        ['--name=NAME',    'Full name of the user to find.'],\n        ['-w',             'Wide output - When listing users use the whole available screen width'],\n\n        'Manipulation of user database:',\n        'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>',\n        'disable user <userEmail> [--verbose|-v]'          => 'Disable user with email <userEmail>',\n\n        [ '<userEmail>', 'user email',        'Full email address of the user to change.'],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing'],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish'],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing'],\n\n    );\n}",
            "title": "Mixing styles"
        },
        {
            "location": "/mvc/modules/#best-practices",
            "text": "Here are the best practices when providing usage for your commands:   Your module's  getConsoleBanner()  method should return a one-line string\n   containing the module's name and its version (if available); do not provide any\n   other information.  Your  getConsoleUsage()  method should  not  return the module's name, as it\n   is prepended automatically for you by the zend-mvc integration.",
            "title": "Best practices"
        },
        {
            "location": "/mvc/controllers/",
            "text": "Console-aware controllers\n\n\nWhen using the zend-mvc integration with zend-console, a matched route results\nin dispatch of an action controller. In this chapter we will learn how ZF2\nControllers can interact with and return output to console window.\n\n\nHandling console requests\n\n\nConsole requests are very similar to HTTP requests. In fact, they implement a\ncommon interface and are created at the same time in the MVC workflow. \nConsole\nroutes\n match against command line arguments and provide a \ndefaults\n\narray, which holds the \ncontroller\n and \naction\n keys. These correspond with\ncontroller aliases in the \nServiceManager\n, and method names in the controller\nclass. This is analogous to the way HTTP requests are handled under zend-mvc.\n\n\nIn this example we'll use the following route:\n\n\n// in file module/Application/config/module.config.php:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                'list-users' => [\n                    'options' => [\n                        'route'    => 'show [all|disabled|deleted]:mode users [--verbose|-v]',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'show-users',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    /* ... */\n);\n\n\n\nThis route will match commands such as:\n\n\n$ php public/index.php show users\n$ php public/index.php show all users\n$ php public/index.php show disabled users\n\n\n\nThis route maps to the method \nApplication\\Controller\\IndexController::showUsersAction()\n.\n\n\nLet's add it that method to our controller.\n\n\n<?php\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController\n{\n    public function indexAction()\n    {\n        return new ViewModel(); // display standard index page\n    }\n\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n        $users   = $this->getServiceLocator()->get('users');\n\n        // Check verbose flag\n        $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n        // Check mode\n        $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n        $users = array();\n        switch ($mode) {\n            case 'disabled':\n                $users = $users->fetchDisabledUsers();\n                break;\n            case 'deleted':\n                $users = $users->fetchDeletedUsers();\n                break;\n            case 'all':\n            default:\n                $users = $users->fetchAllUsers();\n                break;\n        }\n    }\n}\n\n\n\nWe fetch the console request, read parameters, and load users from our\n(theoretical) users service.  In order to make this method functional, we'll\nhave to display the result in the console window.\n\n\nSending output to the console\n\n\nThe simplest way for our controller to display data in the console window is to\nreturn a string. Let's modify our example to output a list of users:\n\n\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n    $users   = $this->getServiceLocator()->get('users');\n\n    // Check verbose flag\n    $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n    // Check mode\n    $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n    $users = array();\n    switch ($mode) {\n        case 'disabled':\n            $users = $users->fetchDisabledUsers();\n            break;\n        case 'deleted':\n            $users = $users->fetchDeletedUsers();\n            break;\n        case 'all':\n        default:\n            $users = $users->fetchAllUsers();\n            break;\n    }\n\n    if (count($users) === 0) {\n        // Show an error message in the console\n        return \"There are no users in the database\\n\";\n    }\n\n    $result = '';\n\n    foreach ($users as $user) {\n        $result .= $user->name . ' ' . $user->email . \"\\n\";\n    }\n\n    return $result; // show it in the console\n}\n\n\n\nIn the second conditional, we are checking if the users service found any users;\nif not, we return an error message to display immediately, terminating the\napplication.\n\n\nIf any users are found, we loop through each to prepare a listing, which we then\nreturn from the action for display in the console.\n\n\nAre we in a console?\n\n\nSometimes we might need to check if our method is being called from a console or\nfrom a web request. This is useful to block certain methods from running in the\nconsole or to change their behavior based on that context.\n\n\nHere is an example of how to check if we are dealing with a console request:\n\n\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console and the user has not tricked our\n        // application into running this action from a public web server.\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException('You can only use this action from a console!');\n        }\n\n        /* ... */\n    }\n}\n\n\n\n\n\nUse routing to protect methods\n\n\nYou do not need to secure all your controllers and methods from console\nrequests. Controller actions will \nonly be invoked\n when at least one\nconsole route matches it.  HTTP and Console routes are separated and defined\nin different places in module (and application) configuration.\n\n\nThere is no way to invoke a console action unless there is at least one route\npointing to it.  Similarly, there is no way for an HTTP action to be invoked\nunless there is at least one HTTP route that points to it.\n\n\n\n\nThe example below shows how a single controller method can handle \nboth Console\nand HTTP requests\n:\n\n\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Http\\Request as HttpRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        $users = array();\n        /* ... fetch users from database ... */\n\n        if ($request instanceof HttpRequest) {\n            // display a web page with users list\n            return new ViewModel($result);\n        }\n\n        if ($request instanceof ConsoleRequest) {\n            // ... prepare console output and return it ...\n            return $result;\n        }\n\n        throw new RuntimeException('Cannot handle request of type ' . get_class($request));\n    }\n}\n\n\n\n\n\nAbstractConsoleController\n\n\nOne way to ensure you always receive a console request instance is to extend\n\nZend\\Mvc\\Controller\\AbstractConsoleController\n. This controller instance also\nexposes a new method, \ngetConsole()\n, providing you access to the console\nadapter, allowing you to use prompts, send output (including colorized output),\nand more.\n\n\n\n\nReading values from console parameters\n\n\nThere are several types of parameters recognized by the Console component, all\nof which are described in the \nconsole routing chapter\n. Here, we'll\nfocus on how to retrieve values from distinct parameters and flags.\n\n\nPositional parameters\n\n\nAfter a route matches, we can access both \nliteral parameters\n and \nvalue\nparameters\n via the \n$request\n instance, using the \ngetParam()\n method.\n\n\nAssuming we have the following route:\n\n\n'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin) [<groupName>]'\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n],\n\n\n\nIf this route matches, our action can now query parameters in the following way:\n\n\n// an action inside Application\\Controller\\UsersController:\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // Literal parameters can be checked with isset() against their exact spelling\n    if (isset($request->getParam('all'))) {\n        // show all users\n    } elseif (isset($request->getParam('deleted'))) {\n        // show deleted users\n    }\n\n    /* ... */\n}\n\n\n\nIn case of parameter alternatives, it is a good idea to \nassign a name to the group\n, which\nsimplifies the branching in our action controllers. We can do this with the following syntax:\n\n\n// inside of config.console.router.routes:\n'show-users' => array(\n    'options' => array(\n        'route'    => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]'\n        'defaults' => array(\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers'\n        )\n    )\n)\n\n\n\nNow we can use a the group name \nuserTypeFilter\n to check which option has been\nselected by the user:\n\n\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // The selected option from second parameter is now stored under 'userTypeFilter'\n    $userTypeFilter = $request->getParam('userTypeFilter');\n\n    switch ($userTypeFilter) {\n        case 'all':\n            // all users\n        case 'deleted':\n            // deleted users\n        case 'locked'\n           // ...\n           // ...\n    }\n}\n\n\n\nFlags\n\n\nFlags are directly accessible by name. Value-capturing flags will contain string\nvalues, as provided by the user. Non-value flags will be equal to \ntrue\n, or\n\nnull\n if not present.\n\n\nGiven the following route:\n\n\n'find-user' => [\n    'options' => [\n        'route'    => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=] ',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'find',\n        ],\n    ],\n],\n\n\n\nWe can retrieve values in the following fashion:\n\n\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // We can retrieve values from value flags using their name\n    $searchId        = $request->getParam('id',        null); // default null\n    $searchFirstName = $request->getParam('firstName', null);\n    $searchLastName  = $request->getParam('lastName',  null);\n    $searchEmail     = $request->getParam('email',     null);\n\n    // Standard flags that have been matched will be equal to TRUE\n    $isFast          = (bool) $request->getParam('fast',    false); // default false\n    $isVerbose       = (bool) $request->getParam('verbose', false);\n\n    if ($isFast) {\n        // perform a fast query ...\n    } else {\n        // perform standard query ...\n    }\n}\n\n\n\nIn case of \nflag alternatives\n, we have to check each alternative separately:\n\n\n/*\n * Assuming our route now reads:\n *      'route'    => 'find user [--fast|-f] [--verbose|-v] ... ',\n */\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // Check both alternatives\n    $isFast    = $request->getParam('fast', false)    || $request->getParam('f', false);\n    $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false);\n\n    // ...\n}",
            "title": "Console-Aware Controllers"
        },
        {
            "location": "/mvc/controllers/#console-aware-controllers",
            "text": "When using the zend-mvc integration with zend-console, a matched route results\nin dispatch of an action controller. In this chapter we will learn how ZF2\nControllers can interact with and return output to console window.",
            "title": "Console-aware controllers"
        },
        {
            "location": "/mvc/controllers/#handling-console-requests",
            "text": "Console requests are very similar to HTTP requests. In fact, they implement a\ncommon interface and are created at the same time in the MVC workflow.  Console\nroutes  match against command line arguments and provide a  defaults \narray, which holds the  controller  and  action  keys. These correspond with\ncontroller aliases in the  ServiceManager , and method names in the controller\nclass. This is analogous to the way HTTP requests are handled under zend-mvc.  In this example we'll use the following route:  // in file module/Application/config/module.config.php:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                'list-users' => [\n                    'options' => [\n                        'route'    => 'show [all|disabled|deleted]:mode users [--verbose|-v]',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'show-users',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n\n    /* ... */\n);  This route will match commands such as:  $ php public/index.php show users\n$ php public/index.php show all users\n$ php public/index.php show disabled users  This route maps to the method  Application\\Controller\\IndexController::showUsersAction() .  Let's add it that method to our controller.  <?php\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController\n{\n    public function indexAction()\n    {\n        return new ViewModel(); // display standard index page\n    }\n\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n        $users   = $this->getServiceLocator()->get('users');\n\n        // Check verbose flag\n        $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n        // Check mode\n        $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n        $users = array();\n        switch ($mode) {\n            case 'disabled':\n                $users = $users->fetchDisabledUsers();\n                break;\n            case 'deleted':\n                $users = $users->fetchDeletedUsers();\n                break;\n            case 'all':\n            default:\n                $users = $users->fetchAllUsers();\n                break;\n        }\n    }\n}  We fetch the console request, read parameters, and load users from our\n(theoretical) users service.  In order to make this method functional, we'll\nhave to display the result in the console window.",
            "title": "Handling console requests"
        },
        {
            "location": "/mvc/controllers/#sending-output-to-the-console",
            "text": "The simplest way for our controller to display data in the console window is to\nreturn a string. Let's modify our example to output a list of users:  public function showUsersAction()\n{\n    $request = $this->getRequest();\n    $users   = $this->getServiceLocator()->get('users');\n\n    // Check verbose flag\n    $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n    // Check mode\n    $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n    $users = array();\n    switch ($mode) {\n        case 'disabled':\n            $users = $users->fetchDisabledUsers();\n            break;\n        case 'deleted':\n            $users = $users->fetchDeletedUsers();\n            break;\n        case 'all':\n        default:\n            $users = $users->fetchAllUsers();\n            break;\n    }\n\n    if (count($users) === 0) {\n        // Show an error message in the console\n        return \"There are no users in the database\\n\";\n    }\n\n    $result = '';\n\n    foreach ($users as $user) {\n        $result .= $user->name . ' ' . $user->email . \"\\n\";\n    }\n\n    return $result; // show it in the console\n}  In the second conditional, we are checking if the users service found any users;\nif not, we return an error message to display immediately, terminating the\napplication.  If any users are found, we loop through each to prepare a listing, which we then\nreturn from the action for display in the console.",
            "title": "Sending output to the console"
        },
        {
            "location": "/mvc/controllers/#are-we-in-a-console",
            "text": "Sometimes we might need to check if our method is being called from a console or\nfrom a web request. This is useful to block certain methods from running in the\nconsole or to change their behavior based on that context.  Here is an example of how to check if we are dealing with a console request:  namespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console and the user has not tricked our\n        // application into running this action from a public web server.\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException('You can only use this action from a console!');\n        }\n\n        /* ... */\n    }\n}",
            "title": "Are we in a console?"
        },
        {
            "location": "/mvc/controllers/#use-routing-to-protect-methods",
            "text": "You do not need to secure all your controllers and methods from console\nrequests. Controller actions will  only be invoked  when at least one\nconsole route matches it.  HTTP and Console routes are separated and defined\nin different places in module (and application) configuration.  There is no way to invoke a console action unless there is at least one route\npointing to it.  Similarly, there is no way for an HTTP action to be invoked\nunless there is at least one HTTP route that points to it.   The example below shows how a single controller method can handle  both Console\nand HTTP requests :  namespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Http\\Request as HttpRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        $users = array();\n        /* ... fetch users from database ... */\n\n        if ($request instanceof HttpRequest) {\n            // display a web page with users list\n            return new ViewModel($result);\n        }\n\n        if ($request instanceof ConsoleRequest) {\n            // ... prepare console output and return it ...\n            return $result;\n        }\n\n        throw new RuntimeException('Cannot handle request of type ' . get_class($request));\n    }\n}",
            "title": "Use routing to protect methods"
        },
        {
            "location": "/mvc/controllers/#abstractconsolecontroller",
            "text": "One way to ensure you always receive a console request instance is to extend Zend\\Mvc\\Controller\\AbstractConsoleController . This controller instance also\nexposes a new method,  getConsole() , providing you access to the console\nadapter, allowing you to use prompts, send output (including colorized output),\nand more.",
            "title": "AbstractConsoleController"
        },
        {
            "location": "/mvc/controllers/#reading-values-from-console-parameters",
            "text": "There are several types of parameters recognized by the Console component, all\nof which are described in the  console routing chapter . Here, we'll\nfocus on how to retrieve values from distinct parameters and flags.",
            "title": "Reading values from console parameters"
        },
        {
            "location": "/mvc/controllers/#positional-parameters",
            "text": "After a route matches, we can access both  literal parameters  and  value\nparameters  via the  $request  instance, using the  getParam()  method.  Assuming we have the following route:  'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin) [<groupName>]'\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n],  If this route matches, our action can now query parameters in the following way:  // an action inside Application\\Controller\\UsersController:\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // Literal parameters can be checked with isset() against their exact spelling\n    if (isset($request->getParam('all'))) {\n        // show all users\n    } elseif (isset($request->getParam('deleted'))) {\n        // show deleted users\n    }\n\n    /* ... */\n}  In case of parameter alternatives, it is a good idea to  assign a name to the group , which\nsimplifies the branching in our action controllers. We can do this with the following syntax:  // inside of config.console.router.routes:\n'show-users' => array(\n    'options' => array(\n        'route'    => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]'\n        'defaults' => array(\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers'\n        )\n    )\n)  Now we can use a the group name  userTypeFilter  to check which option has been\nselected by the user:  public function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // The selected option from second parameter is now stored under 'userTypeFilter'\n    $userTypeFilter = $request->getParam('userTypeFilter');\n\n    switch ($userTypeFilter) {\n        case 'all':\n            // all users\n        case 'deleted':\n            // deleted users\n        case 'locked'\n           // ...\n           // ...\n    }\n}",
            "title": "Positional parameters"
        },
        {
            "location": "/mvc/controllers/#flags",
            "text": "Flags are directly accessible by name. Value-capturing flags will contain string\nvalues, as provided by the user. Non-value flags will be equal to  true , or null  if not present.  Given the following route:  'find-user' => [\n    'options' => [\n        'route'    => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=] ',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'find',\n        ],\n    ],\n],  We can retrieve values in the following fashion:  public function findAction()\n{\n    $request = $this->getRequest();\n\n    // We can retrieve values from value flags using their name\n    $searchId        = $request->getParam('id',        null); // default null\n    $searchFirstName = $request->getParam('firstName', null);\n    $searchLastName  = $request->getParam('lastName',  null);\n    $searchEmail     = $request->getParam('email',     null);\n\n    // Standard flags that have been matched will be equal to TRUE\n    $isFast          = (bool) $request->getParam('fast',    false); // default false\n    $isVerbose       = (bool) $request->getParam('verbose', false);\n\n    if ($isFast) {\n        // perform a fast query ...\n    } else {\n        // perform standard query ...\n    }\n}  In case of  flag alternatives , we have to check each alternative separately:  /*\n * Assuming our route now reads:\n *      'route'    => 'find user [--fast|-f] [--verbose|-v] ... ',\n */\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // Check both alternatives\n    $isFast    = $request->getParam('fast', false)    || $request->getParam('f', false);\n    $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false);\n\n    // ...\n}",
            "title": "Flags"
        },
        {
            "location": "/getopt/intro/",
            "text": "Zend\\Console\\Getopt\n\n\nThe \nZend\\Console\\Getopt\n class helps command-line applications to parse their\noptions and arguments.\n\n\nUsers may specify command-line arguments when they execute your application. These arguments have\nmeaning to the application, to change the behavior in some way, or choose resources, or specify\nparameters. Many options have developed customary meaning, for example \n--verbose\n enables extra\noutput from many applications. Other options may have a meaning that is different for each\napplication. For example, \n-c\n enables different features in \ngrep\n, \nls\n, and \ntar\n.\n\n\nBelow are a few definitions of terms. Common usage of the terms varies, but this documentation will\nuse the definitions below.\n\n\n\n\n\"argument\": a string that occurs on the command-line following the name of the\n  command. Arguments may be options or else may appear without an option, to\n  name resources on which the command operates.\n\n\n\"option\": an argument that signifies that the command should change its\n  default behavior in some way.\n\n\n\"flag\": the first part of an option, identifies the purpose of the option. A\n  flag is preceded conventionally by one or two dashes (\n-\n or \n--\n). A single\n  dash precedes a single-character flag or a cluster of single-character flags.\n  A double-dash precedes a multi-character flag. Long flags cannot be clustered.\n\n\n\"parameter\": the secondary part of an option; a data value that may accompany\n  a flag, if it is applicable to the given option. For example, many commands\n  accept a \n--verbose\n option, but typically this option has no parameter.\n  However, an option like \n--user\n almost always requires a following parameter.\n\n\n\n\nA parameter may be given as a separate argument following a flag argument, or\n  as part of the same argument string, separated from the flag by an equals symbol\n  (\n=\n). The latter form is supported only by long flags. For example, \n-u\n  username\n, \n--user username\n, and \n--user=username\n are forms supported by\n  \nZend\\Console\\Getopt\n.\n- \"cluster\": multiple single-character flags combined in a single string\n  argument and preceded by a single dash. For example, \"\nls -1str\n\" uses a\n  cluster of four short flags. This command is equivalent to \"\nls -1 -s -t -r\n\".\n  Only single-character flags can be clustered. You cannot make a cluster of\n  long flags.\n\n\nFor example, in \nmysql --user=root mydatabase\n, \nmysql\n is a \ncommand\n,\n\n--user=root\n is an \noption\n (\n--user\n is a \nflag\n and \nroot\n is a\n\nparameter\n to the option), and \nmydatabase\n is an argument (but not an option\nby our definition).\n\n\nZend\\Console\\Getopt\n provides an interface to declare which flags are valid for\nyour application, output an error and usage message if they invalid flags are\nspecified, and report to your application which flags the user specified.\n\n\n\n\nGetopt is not an Application Framework\n\n\nZend\\Console\\Getopt\n does \nnot\n interpret the meaning of flags and\nparameters, nor does this class implement application workflow or invoke\napplication code. You must implement those actions in your own application\ncode. You can use the \nZend\\Console\\Getopt\n class to parse the command-line\nand provide object-oriented methods for querying which options were given by a\nuser, but code to use this information to invoke parts of your application\nshould be in another PHP class.\n\n\n\n\nThe following sections describe usage of \nZend\\Console\\Getopt\n.",
            "title": "Introduction"
        },
        {
            "location": "/getopt/intro/#zend92console92getopt",
            "text": "The  Zend\\Console\\Getopt  class helps command-line applications to parse their\noptions and arguments.  Users may specify command-line arguments when they execute your application. These arguments have\nmeaning to the application, to change the behavior in some way, or choose resources, or specify\nparameters. Many options have developed customary meaning, for example  --verbose  enables extra\noutput from many applications. Other options may have a meaning that is different for each\napplication. For example,  -c  enables different features in  grep ,  ls , and  tar .  Below are a few definitions of terms. Common usage of the terms varies, but this documentation will\nuse the definitions below.   \"argument\": a string that occurs on the command-line following the name of the\n  command. Arguments may be options or else may appear without an option, to\n  name resources on which the command operates.  \"option\": an argument that signifies that the command should change its\n  default behavior in some way.  \"flag\": the first part of an option, identifies the purpose of the option. A\n  flag is preceded conventionally by one or two dashes ( -  or  -- ). A single\n  dash precedes a single-character flag or a cluster of single-character flags.\n  A double-dash precedes a multi-character flag. Long flags cannot be clustered.  \"parameter\": the secondary part of an option; a data value that may accompany\n  a flag, if it is applicable to the given option. For example, many commands\n  accept a  --verbose  option, but typically this option has no parameter.\n  However, an option like  --user  almost always requires a following parameter.   A parameter may be given as a separate argument following a flag argument, or\n  as part of the same argument string, separated from the flag by an equals symbol\n  ( = ). The latter form is supported only by long flags. For example,  -u\n  username ,  --user username , and  --user=username  are forms supported by\n   Zend\\Console\\Getopt .\n- \"cluster\": multiple single-character flags combined in a single string\n  argument and preceded by a single dash. For example, \" ls -1str \" uses a\n  cluster of four short flags. This command is equivalent to \" ls -1 -s -t -r \".\n  Only single-character flags can be clustered. You cannot make a cluster of\n  long flags.  For example, in  mysql --user=root mydatabase ,  mysql  is a  command , --user=root  is an  option  ( --user  is a  flag  and  root  is a parameter  to the option), and  mydatabase  is an argument (but not an option\nby our definition).  Zend\\Console\\Getopt  provides an interface to declare which flags are valid for\nyour application, output an error and usage message if they invalid flags are\nspecified, and report to your application which flags the user specified.",
            "title": "Zend\\Console\\Getopt"
        },
        {
            "location": "/getopt/intro/#getopt-is-not-an-application-framework",
            "text": "Zend\\Console\\Getopt  does  not  interpret the meaning of flags and\nparameters, nor does this class implement application workflow or invoke\napplication code. You must implement those actions in your own application\ncode. You can use the  Zend\\Console\\Getopt  class to parse the command-line\nand provide object-oriented methods for querying which options were given by a\nuser, but code to use this information to invoke parts of your application\nshould be in another PHP class.   The following sections describe usage of  Zend\\Console\\Getopt .",
            "title": "Getopt is not an Application Framework"
        },
        {
            "location": "/getopt/rules/",
            "text": "Declaring Getopt Rules\n\n\nThe constructor for the \nZend\\Console\\Getopt\n class takes from one to three\narguments. The first argument declares which options are supported by your\napplication. This class supports alternative syntax forms for declaring the\noptions. See the sections below for the format and usage of these syntax forms.\n\n\nThe constructor takes two more arguments, both of which are optional. The second\nargument may contain the command-line arguments. This defaults to\n\n$_SERVER['argv']\n.\n\n\nThe third argument of the constructor may contain any configuration options\nrequired to customize the behavior of \nZend\\Console\\Getopt\n. See\n\nAdding Configuration\n for a reference on\nthe options available.\n\n\nDeclaring Options with the Short Syntax\n\n\nZend\\Console\\Getopt\n supports a compact syntax similar to that used by\n\nGNU Getopt\n.\nThis syntax supports only single-character flags. In a single string, you type\neach of the letters that correspond to flags supported by your application. A\nletter followed by a colon character (\n:\n) indicates a flag that requires a\nparameter.\n\n\nUsing the Short Syntax\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n\n\n\nThe example above shows using \nZend\\Console\\Getopt\n to declare that options may\nbe given as \n-a\n, \n-b\n, or \n-p\n. The latter flag requires a parameter.\n\n\nThe short syntax is limited to flags of a single character. Aliases, parameter\ntypes, and help strings are not supported in the short syntax.\n\n\nDeclaring Options with the Long Syntax\n\n\nA different syntax with more features is also available. This syntax allows you\nto specify aliases for flags, types of option parameters, and also help strings\nto describe usage to the user. Instead of the single string used in the short\nsyntax to declare the options, the long syntax uses an associative array as the\nfirst argument to the constructor.\n\n\nThe key of each element of the associative array is a string with a format that\nnames the flag, with any aliases, separated by the pipe symbol (\n|\n). Following\nthis series of flag aliases, if the option requires a parameter, is an equals\nsymbol (\n=\n) with a letter that stands for the \ntype\n of the parameter:\n\n\n\n\n=s\n for a string parameter\n\n\n=w\n for a word parameter (a string containing no whitespace)\n\n\n=i\n for an integer parameter\n\n\n\n\nIf the parameter is optional, use a dash (\n-\n) instead of the equals symbol.\n\n\nThe value of each element in the associative array is a help string to describe\nto a user how to use your program.\n\n\nUsing the Long Syntax\n\n\n$opts = new Zend\\Console\\Getopt(\n  array(\n    'apple|a'    => 'apple option, with no parameter',\n    'banana|b=i' => 'banana option, with required integer parameter',\n    'pear|p-s'   => 'pear option, with optional string parameter'\n  )\n);\n\n\n\nIn the example declaration above, there are three options. \n--apple\n and \n-a\n\nare aliases for each other, and the option takes no parameter. \n--banana\n and\n\n-b\n are aliases for each other, and the option takes a mandatory integer\nparameter. Finally, \n--pear\n and \n-p\n are aliases for each other, and the option\nmay take an optional string parameter.",
            "title": "Declaring Rules"
        },
        {
            "location": "/getopt/rules/#declaring-getopt-rules",
            "text": "The constructor for the  Zend\\Console\\Getopt  class takes from one to three\narguments. The first argument declares which options are supported by your\napplication. This class supports alternative syntax forms for declaring the\noptions. See the sections below for the format and usage of these syntax forms.  The constructor takes two more arguments, both of which are optional. The second\nargument may contain the command-line arguments. This defaults to $_SERVER['argv'] .  The third argument of the constructor may contain any configuration options\nrequired to customize the behavior of  Zend\\Console\\Getopt . See Adding Configuration  for a reference on\nthe options available.",
            "title": "Declaring Getopt Rules"
        },
        {
            "location": "/getopt/rules/#declaring-options-with-the-short-syntax",
            "text": "Zend\\Console\\Getopt  supports a compact syntax similar to that used by GNU Getopt .\nThis syntax supports only single-character flags. In a single string, you type\neach of the letters that correspond to flags supported by your application. A\nletter followed by a colon character ( : ) indicates a flag that requires a\nparameter.",
            "title": "Declaring Options with the Short Syntax"
        },
        {
            "location": "/getopt/rules/#using-the-short-syntax",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');  The example above shows using  Zend\\Console\\Getopt  to declare that options may\nbe given as  -a ,  -b , or  -p . The latter flag requires a parameter.  The short syntax is limited to flags of a single character. Aliases, parameter\ntypes, and help strings are not supported in the short syntax.",
            "title": "Using the Short Syntax"
        },
        {
            "location": "/getopt/rules/#declaring-options-with-the-long-syntax",
            "text": "A different syntax with more features is also available. This syntax allows you\nto specify aliases for flags, types of option parameters, and also help strings\nto describe usage to the user. Instead of the single string used in the short\nsyntax to declare the options, the long syntax uses an associative array as the\nfirst argument to the constructor.  The key of each element of the associative array is a string with a format that\nnames the flag, with any aliases, separated by the pipe symbol ( | ). Following\nthis series of flag aliases, if the option requires a parameter, is an equals\nsymbol ( = ) with a letter that stands for the  type  of the parameter:   =s  for a string parameter  =w  for a word parameter (a string containing no whitespace)  =i  for an integer parameter   If the parameter is optional, use a dash ( - ) instead of the equals symbol.  The value of each element in the associative array is a help string to describe\nto a user how to use your program.",
            "title": "Declaring Options with the Long Syntax"
        },
        {
            "location": "/getopt/rules/#using-the-long-syntax",
            "text": "$opts = new Zend\\Console\\Getopt(\n  array(\n    'apple|a'    => 'apple option, with no parameter',\n    'banana|b=i' => 'banana option, with required integer parameter',\n    'pear|p-s'   => 'pear option, with optional string parameter'\n  )\n);  In the example declaration above, there are three options.  --apple  and  -a \nare aliases for each other, and the option takes no parameter.  --banana  and -b  are aliases for each other, and the option takes a mandatory integer\nparameter. Finally,  --pear  and  -p  are aliases for each other, and the option\nmay take an optional string parameter.",
            "title": "Using the Long Syntax"
        },
        {
            "location": "/getopt/fetching/",
            "text": "Fetching Options and Arguments\n\n\nAfter you have declared the options that the \nZend\\Console\\Getopt\n object should\nrecognize, and supplied arguments from the command-line or an array, you can\nquery the object to find out which options were specified by a user in a given\ncommand-line invocation of your program. The class implements magic methods so\nyou can query for options by name.\n\n\nThe parsing of the data is deferred until the first query you make against the\n\nZend\\Console\\Getopt\n object to find out if an option was given.  This allows\nyou to use several method calls to configure the options, arguments, help\nstrings, and configuration options before parsing takes place.\n\n\nHandling Getopt Exceptions\n\n\nIf the user gave any invalid options on the command-line, the parsing function\nthrows a \nZend\\Console\\Exception\\RuntimeException\n. You should catch this\nexception in your application code. You can use the \nparse()\n method to force\nthe object to parse the arguments. This is useful because you can invoke\n\nparse()\n in a \ntry\n block; if it passes, you can be sure that the parsing won't\nthrow an exception again. The exception thrown has a custom method\n\ngetUsageMessage()\n which returns as a string the formatted set of usage\nmessages for all declared options.\n\n\nCatching Getopt Exceptions\n\n\ntry {\n    $opts = new Zend\\Console\\Getopt('abp:');\n    $opts->parse();\n} catch (Zend\\Console\\Exception\\RuntimeException $e) {\n    echo $e->getUsageMessage();\n    exit;\n}\n\n\n\nCases where parsing throws an exception include:\n\n\n\n\nOption given is not recognized.\n\n\nOption requires a parameter but none was given.\n\n\nOption parameter is of the wrong type; e.g. a non-numeric string when an\n  integer was required.\n\n\n\n\nFetching Options by Name\n\n\nYou can use the \ngetOption()\n method to query the value of an option. If the\noption had a parameter, this method returns the value of the parameter. If the\noption had no parameter but the user did specify it on the command-line, the\nmethod returns \nTRUE\n. Otherwise the method returns \nNULL\n.\n\n\nUsing getOption()\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$b = $opts->getOption('b');\n$p_parameter = $opts->getOption('p');\n\n\n\nAlternatively, you can use the property overloading via the magic \n__isset()\n and\n\n__get()\n methods, allowing you to test for and retrieve values as if they were\nproperty names.\n\n\nUsing property overloading\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\nif (isset($opts->b)) {\n    echo \"I got the b option.\\n\";\n}\n$p_parameter = $opts->p; // null if not set\n\n\n\n\n\nUsing aliases\n\n\nIf your options are declared with aliases, you may use any of the aliases for\nan option when retrieving its value.\n\n\n\n\nReporting Options\n\n\nThere are several methods to report the full set of options given by the user on the current\ncommand-line.\n\n\n\n\nAs a string: use the \ntoString()\n method. The options are returned as a\n  space-separated string of \nflag=value\n pairs. The value of an option that does\n  not have a parameter is the literal string \"\nTRUE\n\".\n\n\nAs an array: use the \ntoArray()\n method. The options are returned in a simple\n  integer-indexed array of strings, the flag strings followed by parameter\n  strings, if any.\n\n\nAs a string containing JSON data: use the \ntoJson()\n method.\n\n\nAs a string containing XML data: use the \ntoXml()\n method.\n\n\n\n\nIn all of the above dumping methods, the flag strings are the first strings in\nthe corresponding list of aliases. For example, if the option aliases were\ndeclared like \nverbose|v\n, then the first string, \nverbose\n, is used as the\ncanonical name of the option. The name of the option flag does not include any\npreceding dashes.\n\n\nFetching Non-option Arguments\n\n\nAfter option arguments and their parameters have been parsed from the\ncommand-line, there may be additional arguments remaining. You can query these\narguments using the \ngetRemainingArgs()\n method.  This method returns an array\nof the strings that were not part of any options.\n\n\nUsing getRemainingArgs()\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setArguments(['-p', 'p_parameter', 'filename']);\n$args = $opts->getRemainingArgs(); // returns ['filename']\n\n\n\nZend\\Console\\Getopt\n supports the GNU convention that an argument consisting of\na double-dash signifies the end of options. Any arguments following this\nsignifier must be treated as non-option arguments. This is useful if you might\nhave a non-option argument that begins with a dash. For example: \nrm --\n-filename-with-dash\n.",
            "title": "Fetching Options and Arguments"
        },
        {
            "location": "/getopt/fetching/#fetching-options-and-arguments",
            "text": "After you have declared the options that the  Zend\\Console\\Getopt  object should\nrecognize, and supplied arguments from the command-line or an array, you can\nquery the object to find out which options were specified by a user in a given\ncommand-line invocation of your program. The class implements magic methods so\nyou can query for options by name.  The parsing of the data is deferred until the first query you make against the Zend\\Console\\Getopt  object to find out if an option was given.  This allows\nyou to use several method calls to configure the options, arguments, help\nstrings, and configuration options before parsing takes place.",
            "title": "Fetching Options and Arguments"
        },
        {
            "location": "/getopt/fetching/#handling-getopt-exceptions",
            "text": "If the user gave any invalid options on the command-line, the parsing function\nthrows a  Zend\\Console\\Exception\\RuntimeException . You should catch this\nexception in your application code. You can use the  parse()  method to force\nthe object to parse the arguments. This is useful because you can invoke parse()  in a  try  block; if it passes, you can be sure that the parsing won't\nthrow an exception again. The exception thrown has a custom method getUsageMessage()  which returns as a string the formatted set of usage\nmessages for all declared options.",
            "title": "Handling Getopt Exceptions"
        },
        {
            "location": "/getopt/fetching/#catching-getopt-exceptions",
            "text": "try {\n    $opts = new Zend\\Console\\Getopt('abp:');\n    $opts->parse();\n} catch (Zend\\Console\\Exception\\RuntimeException $e) {\n    echo $e->getUsageMessage();\n    exit;\n}  Cases where parsing throws an exception include:   Option given is not recognized.  Option requires a parameter but none was given.  Option parameter is of the wrong type; e.g. a non-numeric string when an\n  integer was required.",
            "title": "Catching Getopt Exceptions"
        },
        {
            "location": "/getopt/fetching/#fetching-options-by-name",
            "text": "You can use the  getOption()  method to query the value of an option. If the\noption had a parameter, this method returns the value of the parameter. If the\noption had no parameter but the user did specify it on the command-line, the\nmethod returns  TRUE . Otherwise the method returns  NULL .",
            "title": "Fetching Options by Name"
        },
        {
            "location": "/getopt/fetching/#using-getoption",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\n$b = $opts->getOption('b');\n$p_parameter = $opts->getOption('p');  Alternatively, you can use the property overloading via the magic  __isset()  and __get()  methods, allowing you to test for and retrieve values as if they were\nproperty names.",
            "title": "Using getOption()"
        },
        {
            "location": "/getopt/fetching/#using-property-overloading",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\nif (isset($opts->b)) {\n    echo \"I got the b option.\\n\";\n}\n$p_parameter = $opts->p; // null if not set",
            "title": "Using property overloading"
        },
        {
            "location": "/getopt/fetching/#using-aliases",
            "text": "If your options are declared with aliases, you may use any of the aliases for\nan option when retrieving its value.",
            "title": "Using aliases"
        },
        {
            "location": "/getopt/fetching/#reporting-options",
            "text": "There are several methods to report the full set of options given by the user on the current\ncommand-line.   As a string: use the  toString()  method. The options are returned as a\n  space-separated string of  flag=value  pairs. The value of an option that does\n  not have a parameter is the literal string \" TRUE \".  As an array: use the  toArray()  method. The options are returned in a simple\n  integer-indexed array of strings, the flag strings followed by parameter\n  strings, if any.  As a string containing JSON data: use the  toJson()  method.  As a string containing XML data: use the  toXml()  method.   In all of the above dumping methods, the flag strings are the first strings in\nthe corresponding list of aliases. For example, if the option aliases were\ndeclared like  verbose|v , then the first string,  verbose , is used as the\ncanonical name of the option. The name of the option flag does not include any\npreceding dashes.",
            "title": "Reporting Options"
        },
        {
            "location": "/getopt/fetching/#fetching-non-option-arguments",
            "text": "After option arguments and their parameters have been parsed from the\ncommand-line, there may be additional arguments remaining. You can query these\narguments using the  getRemainingArgs()  method.  This method returns an array\nof the strings that were not part of any options.",
            "title": "Fetching Non-option Arguments"
        },
        {
            "location": "/getopt/fetching/#using-getremainingargs",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setArguments(['-p', 'p_parameter', 'filename']);\n$args = $opts->getRemainingArgs(); // returns ['filename']  Zend\\Console\\Getopt  supports the GNU convention that an argument consisting of\na double-dash signifies the end of options. Any arguments following this\nsignifier must be treated as non-option arguments. This is useful if you might\nhave a non-option argument that begins with a dash. For example:  rm --\n-filename-with-dash .",
            "title": "Using getRemainingArgs()"
        },
        {
            "location": "/getopt/configuration/",
            "text": "Configuring Zend\\Console\\Getopt\n\n\nAdding Option Rules\n\n\nYou can add more option rules in addition to those you specified in the\n\nZend\\Console\\Getopt\n constructor via the \naddRules()\n method. The argument to\n\naddRules()\n is the same as the first argument to the class constructor: it is\neither a string in the format of the short syntax options specification, or else\nan associative array in the format of a long syntax options specification.  See\n\nDeclaring Getopt Rules\n for details on the syntax for specifying\noptions.\n\n\nUsing addRules()\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->addRules([\n    'verbose|v' => 'Print verbose output',\n]);\n\n\n\nThe example above shows adding the \n--verbose\n option with an alias of \n-v\n to a set of options\ndefined in the call to the constructor. Notice that you can mix short format options and long format\noptions in the same instance of \nZend\\Console\\Getopt\n.\n\n\nAdding Help Messages\n\n\nIn addition to specifying the help strings when declaring option rules in the\nlong format, you can associate help strings with option rules using the\n\nsetHelp()\n method. The argument to the \nsetHelp()\n method is an associative\narray, in which the key is a flag, and the value is a corresponding help string.\n\n\nUsing setHelp()\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setHelp([\n    'a' => 'apple option, with no parameter',\n    'b' => 'banana option, with required integer parameter',\n    'p' => 'pear option, with optional string parameter',\n]);\n\n\n\nIf you declared options with aliases, you can use any of the aliases as the key\nof the associative array.\n\n\nThe \nsetHelp()\n method is the only way to define help strings if you declared\nthe options using the short syntax.\n\n\nAdding Option Aliases\n\n\nYou can declare aliases for options using the \nsetAliases()\n method. The\nargument is an associative array, where keys are flag strings declared\npreviously, and values are new aliases for the flags.  These aliases are\nmerged with any existing aliases. In other words, aliases you declared earlier\nare still in effect.\n\n\nAn alias may be declared only once. If you try to redefine an alias, a\n\nZend\\Console\\Getopt\\Exception\n is thrown.\n\n\nUsing setAliases()\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setAliases([\n    'a' => 'apple',\n    'a' => 'apfel',\n    'p' => 'pear',\n]);\n\n\n\nIn the example above, after declaring these aliases, \n-a\n, \n--apple\n and\n\n--apfel\n are aliases for each other. Also \n-p\n and \n--pear\n are aliases for\neach other.\n\n\nThe \nsetAliases()\n method is the only way to define aliases if you declared the\noptions using the short syntax.\n\n\nAdding Argument Lists\n\n\nBy default, \nZend\\Console\\Getopt\n uses \n$_SERVER['argv']\n for the array of\ncommand-line arguments to parse. You can alternatively specify the array of\narguments as the second constructor argument.  Finally, you can append more\narguments to those already used using the \naddArguments()\n method, or you can\nreplace the current array of arguments using the \nsetArguments()\n method. In\nboth cases, the parameter to these methods is a simple array of strings. The\nformer method appends the array to the current arguments, and the latter method\nsubstitutes the array for the current arguments.\n\n\nUsing addArguments() and setArguments()\n\n\n// By default, the constructor uses $_SERVER['argv']\n$opts = new Zend\\Console\\Getopt('abp:');\n\n// Append an array to the existing arguments\n$opts->addArguments(['-a', '-p', 'p_parameter', 'non_option_arg']);\n\n// Substitute a new array for the existing arguments\n$opts->setArguments(['-a', '-p', 'p_parameter', 'non_option_arg']);\n\n\n\nAdding Configuration\n\n\nThe third parameter to the \nZend\\Console\\Getopt\n constructor is an array of\nconfiguration options that affect the behavior of the object instance returned.\nYou can also specify configuration options using the \nsetOptions()\n method, or\nyou can set an individual option using the \nsetOption()\n method.\n\n\n\n\nClarifying the Term \"option\"\n\n\nThe term \"option\" is used for configuration of the \nZend\\Console\\Getopt\n class\nto match terminology used elsewhere in Zend Framework. These are not the same\nthings as the command-line options that are parsed by the\n\nZend\\Console\\Getopt\n class.\n\n\n\n\nThe currently supported options have constant definitions in the class. The\noptions, along with their constant identifiers and literal values (in\nparentheses) are listed below:\n\n\n\n\nZend\\Console\\Getopt::CONFIG_DASHDASH\n (\"dashDash\"), if \nTRUE\n, enables the\n  special flag \n--\n to signify the end of flags. Command-line arguments\n  following the double-dash signifier are not interpreted as options, even if\n  the arguments start with a dash. This configuration option is \nTRUE\n by\n  default.\n\n\nZend\\Console\\Getopt::CONFIG_IGNORECASE\n (\"ignoreCase\"), if \nTRUE\n, makes\n  flags aliases of each other if they differ only in their case. That is, \n-a\n\n  and \n-A\n will be considered to be synonymous flags. This configuration option\n  is \nFALSE\n by default.\n\n\nZend\\Console\\Getopt::CONFIG_RULEMODE\n (\"ruleMode\") may have values\n  \nZend\\Console\\Getopt::MODE_ZEND\n (\"zend\") and \nZend\\Console\\Getopt::MODE_GNU\n\n  (\"gnu\"). It should not be necessary to use this option unless you extend the\n  class with additional syntax forms. The two modes supported in the base\n  \nZend\\Console\\Getopt\n class are unambiguous. If the specifier is a string, the\n  class assumes \nMODE_GNU\n, otherwise it assumes \nMODE_ZEND\n. But if you extend\n  the class and add more syntax forms, you may need to specify the mode using\n  this option.\n\n\n\n\nMore configuration options may be added as future enhancements of this class.\n\n\nUsing setOption()\n\n\nThe two arguments to the \nsetOption()\n method are a configuration option name\nand an option value.\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setOption('ignoreCase', true);\n\n\n\nUsing setOptions()\n\n\nThe argument to the \nsetOptions()\n method is an associative array. The keys of\nthis array are the configuration option names, and the values are configuration\nvalues. This is also the array format used in the class constructor. The\nconfiguration values you specify are merged with the current configuration; you\ndon't have to list all options.\n\n\n$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setOptions([\n    'ignoreCase' => true,\n    'dashDash'   => false,\n]);",
            "title": "Configuration"
        },
        {
            "location": "/getopt/configuration/#configuring-zend92console92getopt",
            "text": "",
            "title": "Configuring Zend\\Console\\Getopt"
        },
        {
            "location": "/getopt/configuration/#adding-option-rules",
            "text": "You can add more option rules in addition to those you specified in the Zend\\Console\\Getopt  constructor via the  addRules()  method. The argument to addRules()  is the same as the first argument to the class constructor: it is\neither a string in the format of the short syntax options specification, or else\nan associative array in the format of a long syntax options specification.  See Declaring Getopt Rules  for details on the syntax for specifying\noptions.",
            "title": "Adding Option Rules"
        },
        {
            "location": "/getopt/configuration/#using-addrules",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\n$opts->addRules([\n    'verbose|v' => 'Print verbose output',\n]);  The example above shows adding the  --verbose  option with an alias of  -v  to a set of options\ndefined in the call to the constructor. Notice that you can mix short format options and long format\noptions in the same instance of  Zend\\Console\\Getopt .",
            "title": "Using addRules()"
        },
        {
            "location": "/getopt/configuration/#adding-help-messages",
            "text": "In addition to specifying the help strings when declaring option rules in the\nlong format, you can associate help strings with option rules using the setHelp()  method. The argument to the  setHelp()  method is an associative\narray, in which the key is a flag, and the value is a corresponding help string.",
            "title": "Adding Help Messages"
        },
        {
            "location": "/getopt/configuration/#using-sethelp",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setHelp([\n    'a' => 'apple option, with no parameter',\n    'b' => 'banana option, with required integer parameter',\n    'p' => 'pear option, with optional string parameter',\n]);  If you declared options with aliases, you can use any of the aliases as the key\nof the associative array.  The  setHelp()  method is the only way to define help strings if you declared\nthe options using the short syntax.",
            "title": "Using setHelp()"
        },
        {
            "location": "/getopt/configuration/#adding-option-aliases",
            "text": "You can declare aliases for options using the  setAliases()  method. The\nargument is an associative array, where keys are flag strings declared\npreviously, and values are new aliases for the flags.  These aliases are\nmerged with any existing aliases. In other words, aliases you declared earlier\nare still in effect.  An alias may be declared only once. If you try to redefine an alias, a Zend\\Console\\Getopt\\Exception  is thrown.",
            "title": "Adding Option Aliases"
        },
        {
            "location": "/getopt/configuration/#using-setaliases",
            "text": "$opts = new Zend\\Console\\Getopt('abp:');\n$opts->setAliases([\n    'a' => 'apple',\n    'a' => 'apfel',\n    'p' => 'pear',\n]);  In the example above, after declaring these aliases,  -a ,  --apple  and --apfel  are aliases for each other. Also  -p  and  --pear  are aliases for\neach other.  The  setAliases()  method is the only way to define aliases if you declared the\noptions using the short syntax.",
            "title": "Using setAliases()"
        },
        {
            "location": "/getopt/configuration/#adding-argument-lists",
            "text": "By default,  Zend\\Console\\Getopt  uses  $_SERVER['argv']  for the array of\ncommand-line arguments to parse. You can alternatively specify the array of\narguments as the second constructor argument.  Finally, you can append more\narguments to those already used using the  addArguments()  method, or you can\nreplace the current array of arguments using the  setArguments()  method. In\nboth cases, the parameter to these methods is a simple array of strings. The\nformer method appends the array to the current arguments, and the latter method\nsubstitutes the array for the current arguments.",
            "title": "Adding Argument Lists"
        },
        {
            "location": "/getopt/configuration/#using-addarguments-and-setarguments",
            "text": "// By default, the constructor uses $_SERVER['argv']\n$opts = new Zend\\Console\\Getopt('abp:');\n\n// Append an array to the existing arguments\n$opts->addArguments(['-a', '-p', 'p_parameter', 'non_option_arg']);\n\n// Substitute a new array for the existing arguments\n$opts->setArguments(['-a', '-p', 'p_parameter', 'non_option_arg']);",
            "title": "Using addArguments() and setArguments()"
        },
        {
            "location": "/getopt/configuration/#adding-configuration",
            "text": "The third parameter to the  Zend\\Console\\Getopt  constructor is an array of\nconfiguration options that affect the behavior of the object instance returned.\nYou can also specify configuration options using the  setOptions()  method, or\nyou can set an individual option using the  setOption()  method.",
            "title": "Adding Configuration"
        },
        {
            "location": "/getopt/configuration/#clarifying-the-term-option",
            "text": "The term \"option\" is used for configuration of the  Zend\\Console\\Getopt  class\nto match terminology used elsewhere in Zend Framework. These are not the same\nthings as the command-line options that are parsed by the Zend\\Console\\Getopt  class.   The currently supported options have constant definitions in the class. The\noptions, along with their constant identifiers and literal values (in\nparentheses) are listed below:   Zend\\Console\\Getopt::CONFIG_DASHDASH  (\"dashDash\"), if  TRUE , enables the\n  special flag  --  to signify the end of flags. Command-line arguments\n  following the double-dash signifier are not interpreted as options, even if\n  the arguments start with a dash. This configuration option is  TRUE  by\n  default.  Zend\\Console\\Getopt::CONFIG_IGNORECASE  (\"ignoreCase\"), if  TRUE , makes\n  flags aliases of each other if they differ only in their case. That is,  -a \n  and  -A  will be considered to be synonymous flags. This configuration option\n  is  FALSE  by default.  Zend\\Console\\Getopt::CONFIG_RULEMODE  (\"ruleMode\") may have values\n   Zend\\Console\\Getopt::MODE_ZEND  (\"zend\") and  Zend\\Console\\Getopt::MODE_GNU \n  (\"gnu\"). It should not be necessary to use this option unless you extend the\n  class with additional syntax forms. The two modes supported in the base\n   Zend\\Console\\Getopt  class are unambiguous. If the specifier is a string, the\n  class assumes  MODE_GNU , otherwise it assumes  MODE_ZEND . But if you extend\n  the class and add more syntax forms, you may need to specify the mode using\n  this option.   More configuration options may be added as future enhancements of this class.",
            "title": "Clarifying the Term \"option\""
        },
        {
            "location": "/getopt/configuration/#using-setoption",
            "text": "The two arguments to the  setOption()  method are a configuration option name\nand an option value.  $opts = new Zend\\Console\\Getopt('abp:');\n$opts->setOption('ignoreCase', true);",
            "title": "Using setOption()"
        },
        {
            "location": "/getopt/configuration/#using-setoptions",
            "text": "The argument to the  setOptions()  method is an associative array. The keys of\nthis array are the configuration option names, and the values are configuration\nvalues. This is also the array format used in the class constructor. The\nconfiguration values you specify are merged with the current configuration; you\ndon't have to list all options.  $opts = new Zend\\Console\\Getopt('abp:');\n$opts->setOptions([\n    'ignoreCase' => true,\n    'dashDash'   => false,\n]);",
            "title": "Using setOptions()"
        }
    ]
}